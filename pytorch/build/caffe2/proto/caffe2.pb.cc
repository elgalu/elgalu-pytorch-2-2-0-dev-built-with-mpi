// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/caffe2.proto

#include "caffe2/proto/caffe2.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto;
namespace caffe2 {
class TensorProto_SegmentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorProto_Segment> _instance;
} _TensorProto_Segment_default_instance_;
class TensorProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorProto> _instance;
} _TensorProto_default_instance_;
class QTensorProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<QTensorProto> _instance;
} _QTensorProto_default_instance_;
class TensorProtosDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorProtos> _instance;
} _TensorProtos_default_instance_;
class TensorShapeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorShape> _instance;
} _TensorShape_default_instance_;
class TensorShapesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorShapes> _instance;
} _TensorShapes_default_instance_;
class TensorBoundShapeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorBoundShape> _instance;
} _TensorBoundShape_default_instance_;
class TensorBoundShapesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TensorBoundShapes> _instance;
} _TensorBoundShapes_default_instance_;
class AOTConfigDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AOTConfig> _instance;
} _AOTConfig_default_instance_;
class ArgumentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Argument> _instance;
} _Argument_default_instance_;
class DeviceOptionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DeviceOption> _instance;
} _DeviceOption_default_instance_;
class OperatorDefDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<OperatorDef> _instance;
} _OperatorDef_default_instance_;
class MapFieldEntryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MapFieldEntry> _instance;
} _MapFieldEntry_default_instance_;
class BackendOptionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BackendOptions> _instance;
} _BackendOptions_default_instance_;
class PartitionInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PartitionInfo> _instance;
} _PartitionInfo_default_instance_;
class NetDefDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NetDef> _instance;
} _NetDef_default_instance_;
class ExecutionStepDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExecutionStep> _instance;
} _ExecutionStep_default_instance_;
class PlanDefDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PlanDef> _instance;
} _PlanDef_default_instance_;
class BlobProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BlobProto> _instance;
} _BlobProto_default_instance_;
class DBReaderProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DBReaderProto> _instance;
} _DBReaderProto_default_instance_;
class BlobSerializationOptionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BlobSerializationOptions> _instance;
} _BlobSerializationOptions_default_instance_;
class SerializationOptionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SerializationOptions> _instance;
} _SerializationOptions_default_instance_;
}  // namespace caffe2
static void InitDefaultsscc_info_AOTConfig_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_AOTConfig_default_instance_;
    new (ptr) ::caffe2::AOTConfig();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::AOTConfig::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AOTConfig_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AOTConfig_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_Argument_default_instance_;
    new (ptr) ::caffe2::Argument();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::caffe2::_OperatorDef_default_instance_;
    new (ptr) ::caffe2::OperatorDef();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::caffe2::_NetDef_default_instance_;
    new (ptr) ::caffe2::NetDef();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::Argument::InitAsDefaultInstance();
  ::caffe2::OperatorDef::InitAsDefaultInstance();
  ::caffe2::NetDef::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, 0, InitDefaultsscc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,
      &scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,
      &scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto.base,
      &scc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_BackendOptions_default_instance_;
    new (ptr) ::caffe2::BackendOptions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::BackendOptions::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_BlobProto_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_BlobProto_default_instance_;
    new (ptr) ::caffe2::BlobProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::BlobProto::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_BlobProto_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_BlobProto_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,
      &scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_BlobSerializationOptions_default_instance_;
    new (ptr) ::caffe2::BlobSerializationOptions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::BlobSerializationOptions::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_DBReaderProto_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_DBReaderProto_default_instance_;
    new (ptr) ::caffe2::DBReaderProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::DBReaderProto::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DBReaderProto_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DBReaderProto_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_DeviceOption_default_instance_;
    new (ptr) ::caffe2::DeviceOption();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::DeviceOption::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_ExecutionStep_default_instance_;
    new (ptr) ::caffe2::ExecutionStep();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::ExecutionStep::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_MapFieldEntry_default_instance_;
    new (ptr) ::caffe2::MapFieldEntry();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::MapFieldEntry::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_PartitionInfo_default_instance_;
    new (ptr) ::caffe2::PartitionInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::PartitionInfo::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_PlanDef_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_PlanDef_default_instance_;
    new (ptr) ::caffe2::PlanDef();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::PlanDef::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_PlanDef_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_PlanDef_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base,
      &scc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_QTensorProto_default_instance_;
    new (ptr) ::caffe2::QTensorProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::QTensorProto::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_SerializationOptions_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_SerializationOptions_default_instance_;
    new (ptr) ::caffe2::SerializationOptions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::SerializationOptions::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SerializationOptions_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_SerializationOptions_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorBoundShape_default_instance_;
    new (ptr) ::caffe2::TensorBoundShape();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorBoundShape::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_TensorBoundShapes_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorBoundShapes_default_instance_;
    new (ptr) ::caffe2::TensorBoundShapes();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorBoundShapes::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TensorBoundShapes_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TensorBoundShapes_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorProto_default_instance_;
    new (ptr) ::caffe2::TensorProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorProto::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto.base,
      &scc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorProto_Segment_default_instance_;
    new (ptr) ::caffe2::TensorProto_Segment();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorProto_Segment::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_TensorProtos_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorProtos_default_instance_;
    new (ptr) ::caffe2::TensorProtos();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorProtos::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TensorProtos_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TensorProtos_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static void InitDefaultsscc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorShape_default_instance_;
    new (ptr) ::caffe2::TensorShape();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorShape::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto}, {}};

static void InitDefaultsscc_info_TensorShapes_caffe2_2fproto_2fcaffe2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::caffe2::_TensorShapes_default_instance_;
    new (ptr) ::caffe2::TensorShapes();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::caffe2::TensorShapes::InitAsDefaultInstance();
}

TORCH_API ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TensorShapes_caffe2_2fproto_2fcaffe2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TensorShapes_caffe2_2fproto_2fcaffe2_2eproto}, {
      &scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_caffe2_2fproto_2fcaffe2_2eproto[22];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_caffe2_2fproto_2fcaffe2_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_caffe2_2fproto_2fcaffe2_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto_Segment, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto_Segment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto_Segment, begin_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto_Segment, end_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, dims_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, data_type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, data_format_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, float_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, int32_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, byte_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, string_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, double_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, int64_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, raw_data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, device_detail_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProto, segment_),
  ~0u,
  6,
  5,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  2,
  1,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, dims_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, precision_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, scale_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, bias_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, is_signed_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, data_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, data_type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, scales_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, biases_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, axis_),
  PROTOBUF_FIELD_OFFSET(::caffe2::QTensorProto, is_multiparam_),
  ~0u,
  3,
  1,
  2,
  4,
  ~0u,
  0,
  7,
  ~0u,
  ~0u,
  6,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProtos, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorProtos, protos_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, dims_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, data_type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, unknown_dims_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, unknown_shape_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShape, name_),
  ~0u,
  2,
  ~0u,
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShapes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorShapes, shapes_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShape, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShape, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShape, shape_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShape, dim_type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShape, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShape, shape_is_final_),
  1,
  ~0u,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShapes, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShapes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShapes, shapes_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShapes, max_batch_size_),
  PROTOBUF_FIELD_OFFSET(::caffe2::TensorBoundShapes, max_feature_len_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, max_batch_size_),
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, max_seq_size_),
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, in_batch_broadcast_),
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, onnxifi_blacklist_ops_),
  PROTOBUF_FIELD_OFFSET(::caffe2::AOTConfig, onnxifi_min_ops_),
  1,
  2,
  3,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, f_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, i_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, s_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, t_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, n_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, floats_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, ints_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, strings_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, tensors_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, nets_),
  PROTOBUF_FIELD_OFFSET(::caffe2::Argument, qtensors_),
  0,
  5,
  4,
  1,
  3,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, device_type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, device_id_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, random_seed_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, node_name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, numa_node_id_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DeviceOption, extra_info_),
  1,
  2,
  3,
  0,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, input_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, output_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, arg_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, device_option_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, engine_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, control_input_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, is_gradient_op_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, debug_info_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, domain_),
  PROTOBUF_FIELD_OFFSET(::caffe2::OperatorDef, op_version_),
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  5,
  2,
  ~0u,
  7,
  3,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::caffe2::MapFieldEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::MapFieldEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::MapFieldEntry, key_),
  PROTOBUF_FIELD_OFFSET(::caffe2::MapFieldEntry, val_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::caffe2::BackendOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BackendOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::BackendOptions, backend_name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BackendOptions, option_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::caffe2::PartitionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PartitionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::PartitionInfo, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PartitionInfo, device_id_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PartitionInfo, extra_info_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PartitionInfo, backend_options_),
  0,
  ~0u,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, op_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, num_workers_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, device_option_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, arg_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, external_input_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, external_output_),
  PROTOBUF_FIELD_OFFSET(::caffe2::NetDef, partition_info_),
  0,
  ~0u,
  1,
  3,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, substep_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, network_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, num_iter_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, criteria_network_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, report_net_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, report_interval_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, run_every_ms_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, concurrent_substeps_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, should_stop_blob_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, only_once_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, create_workspace_),
  PROTOBUF_FIELD_OFFSET(::caffe2::ExecutionStep, num_concurrent_instances_),
  0,
  ~0u,
  ~0u,
  4,
  1,
  2,
  5,
  9,
  6,
  3,
  7,
  8,
  10,
  PROTOBUF_FIELD_OFFSET(::caffe2::PlanDef, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PlanDef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::PlanDef, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PlanDef, network_),
  PROTOBUF_FIELD_OFFSET(::caffe2::PlanDef, execution_step_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, tensor_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, content_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, qtensor_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, content_num_chunks_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobProto, content_chunk_id_),
  0,
  1,
  3,
  2,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::caffe2::DBReaderProto, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DBReaderProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::DBReaderProto, name_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DBReaderProto, source_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DBReaderProto, db_type_),
  PROTOBUF_FIELD_OFFSET(::caffe2::DBReaderProto, key_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobSerializationOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobSerializationOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobSerializationOptions, blob_name_regex_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobSerializationOptions, chunk_size_),
  PROTOBUF_FIELD_OFFSET(::caffe2::BlobSerializationOptions, float_format_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::caffe2::SerializationOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::caffe2::SerializationOptions, options_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::caffe2::TensorProto_Segment)},
  { 9, 27, sizeof(::caffe2::TensorProto)},
  { 40, 57, sizeof(::caffe2::QTensorProto)},
  { 69, -1, sizeof(::caffe2::TensorProtos)},
  { 75, 85, sizeof(::caffe2::TensorShape)},
  { 90, -1, sizeof(::caffe2::TensorShapes)},
  { 96, 105, sizeof(::caffe2::TensorBoundShape)},
  { 109, 117, sizeof(::caffe2::TensorBoundShapes)},
  { 120, 130, sizeof(::caffe2::AOTConfig)},
  { 135, 152, sizeof(::caffe2::Argument)},
  { 164, 175, sizeof(::caffe2::DeviceOption)},
  { 181, 198, sizeof(::caffe2::OperatorDef)},
  { 210, 217, sizeof(::caffe2::MapFieldEntry)},
  { 219, 226, sizeof(::caffe2::BackendOptions)},
  { 228, 237, sizeof(::caffe2::PartitionInfo)},
  { 241, 255, sizeof(::caffe2::NetDef)},
  { 264, 282, sizeof(::caffe2::ExecutionStep)},
  { 295, 303, sizeof(::caffe2::PlanDef)},
  { 306, 318, sizeof(::caffe2::BlobProto)},
  { 325, 334, sizeof(::caffe2::DBReaderProto)},
  { 338, 346, sizeof(::caffe2::BlobSerializationOptions)},
  { 349, -1, sizeof(::caffe2::SerializationOptions)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorProto_Segment_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_QTensorProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorProtos_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorShape_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorShapes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorBoundShape_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_TensorBoundShapes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_AOTConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_Argument_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_DeviceOption_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_OperatorDef_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_MapFieldEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_BackendOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_PartitionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_NetDef_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_ExecutionStep_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_PlanDef_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_BlobProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_DBReaderProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_BlobSerializationOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::caffe2::_SerializationOptions_default_instance_),
};

const char descriptor_table_protodef_caffe2_2fproto_2fcaffe2_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\031caffe2/proto/caffe2.proto\022\006caffe2\"\243\005\n\013"
  "TensorProto\022\014\n\004dims\030\001 \003(\003\0226\n\tdata_type\030\002"
  " \001(\0162\034.caffe2.TensorProto.DataType:\005FLOA"
  "T\022\026\n\013data_format\030\017 \001(\r:\0010\022\026\n\nfloat_data\030"
  "\003 \003(\002B\002\020\001\022\026\n\nint32_data\030\004 \003(\005B\002\020\001\022\021\n\tbyt"
  "e_data\030\005 \001(\014\022\023\n\013string_data\030\006 \003(\014\022\027\n\013dou"
  "ble_data\030\t \003(\001B\002\020\001\022\026\n\nint64_data\030\n \003(\003B\002"
  "\020\001\022\020\n\010raw_data\030\r \001(\014\022\014\n\004name\030\007 \001(\t\022+\n\rde"
  "vice_detail\030\010 \001(\0132\024.caffe2.DeviceOption\022"
  ",\n\007segment\030\013 \001(\0132\033.caffe2.TensorProto.Se"
  "gment\032%\n\007Segment\022\r\n\005begin\030\001 \002(\003\022\013\n\003end\030\002"
  " \002(\003\"\317\001\n\010DataType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOA"
  "T\020\001\022\t\n\005INT32\020\002\022\010\n\004BYTE\020\003\022\n\n\006STRING\020\004\022\010\n\004"
  "BOOL\020\005\022\t\n\005UINT8\020\006\022\010\n\004INT8\020\007\022\n\n\006UINT16\020\010\022"
  "\t\n\005INT16\020\t\022\t\n\005INT64\020\n\022\013\n\007FLOAT16\020\014\022\n\n\006DO"
  "UBLE\020\r\022\027\n\023ZERO_COLLISION_HASH\020\016\022\025\n\021REBAT"
  "CHING_BUFFER\020\017\"9\n\023SerializationFormat\022\020\n"
  "\014FMT_PROTOBUF\020\000\022\020\n\014FMT_BFLOAT16\020\001\"\203\002\n\014QT"
  "ensorProto\022\014\n\004dims\030\001 \003(\003\022\021\n\tprecision\030\002 "
  "\002(\005\022\r\n\005scale\030\003 \002(\001\022\014\n\004bias\030\004 \002(\001\022\021\n\tis_s"
  "igned\030\005 \002(\010\022\020\n\004data\030\006 \003(\005B\002\020\001\022\014\n\004name\030\007 "
  "\001(\t\0226\n\tdata_type\030\010 \001(\0162\034.caffe2.TensorPr"
  "oto.DataType:\005INT32\022\016\n\006scales\030\t \003(\001\022\016\n\006b"
  "iases\030\n \003(\001\022\014\n\004axis\030\013 \001(\005\022\034\n\ris_multipar"
  "am\030\014 \001(\010:\005false\"3\n\014TensorProtos\022#\n\006proto"
  "s\030\001 \003(\0132\023.caffe2.TensorProto\"\225\001\n\013TensorS"
  "hape\022\014\n\004dims\030\001 \003(\003\0226\n\tdata_type\030\002 \001(\0162\034."
  "caffe2.TensorProto.DataType:\005FLOAT\022\024\n\014un"
  "known_dims\030\003 \003(\005\022\034\n\runknown_shape\030\004 \001(\010:"
  "\005false\022\014\n\004name\030\005 \001(\t\"3\n\014TensorShapes\022#\n\006"
  "shapes\030\001 \003(\0132\023.caffe2.TensorShape\"\250\002\n\020Te"
  "nsorBoundShape\022\"\n\005shape\030\001 \001(\0132\023.caffe2.T"
  "ensorShape\0222\n\010dim_type\030\002 \003(\0162 .caffe2.Te"
  "nsorBoundShape.DimType\022\014\n\004name\030\003 \001(\t\022\026\n\016"
  "shape_is_final\030\004 \001(\010\"\225\001\n\007DimType\022\013\n\007UNKN"
  "OWN\020\000\022\014\n\010CONSTANT\020\001\022\t\n\005BATCH\020\002\022\030\n\024BATCH_"
  "OF_FEATURE_MAX\020\003\022 \n\034BATCH_OF_FEATURE_MAX"
  "_DEFAULT\020\004\022\017\n\013FEATURE_MAX\020\005\022\027\n\023FEATURE_M"
  "AX_DEFAULT\020\006\"n\n\021TensorBoundShapes\022(\n\006sha"
  "pes\030\001 \003(\0132\030.caffe2.TensorBoundShape\022\026\n\016m"
  "ax_batch_size\030\002 \001(\003\022\027\n\017max_feature_len\030\003"
  " \001(\003\"\215\001\n\tAOTConfig\022\026\n\016max_batch_size\030\001 \002"
  "(\003\022\024\n\014max_seq_size\030\002 \002(\003\022\032\n\022in_batch_bro"
  "adcast\030\003 \002(\010\022\035\n\025onnxifi_blacklist_ops\030\004 "
  "\001(\t\022\027\n\017onnxifi_min_ops\030\005 \001(\005\"\217\002\n\010Argumen"
  "t\022\014\n\004name\030\001 \001(\t\022\t\n\001f\030\002 \001(\002\022\t\n\001i\030\003 \001(\003\022\t\n"
  "\001s\030\004 \001(\014\022\036\n\001t\030\n \001(\0132\023.caffe2.TensorProto"
  "\022\031\n\001n\030\010 \001(\0132\016.caffe2.NetDef\022\016\n\006floats\030\005 "
  "\003(\002\022\014\n\004ints\030\006 \003(\003\022\017\n\007strings\030\007 \003(\014\022$\n\007te"
  "nsors\030\013 \003(\0132\023.caffe2.TensorProto\022\034\n\004nets"
  "\030\t \003(\0132\016.caffe2.NetDef\022&\n\010qtensors\030\014 \003(\013"
  "2\024.caffe2.QTensorProto\"\213\001\n\014DeviceOption\022"
  "\026\n\013device_type\030\001 \001(\005:\0010\022\021\n\tdevice_id\030\002 \001"
  "(\005\022\023\n\013random_seed\030\003 \001(\r\022\021\n\tnode_name\030\004 \001"
  "(\t\022\024\n\014numa_node_id\030\005 \001(\005\022\022\n\nextra_info\030\006"
  " \003(\t\"\222\002\n\013OperatorDef\022\r\n\005input\030\001 \003(\t\022\016\n\006o"
  "utput\030\002 \003(\t\022\014\n\004name\030\003 \001(\t\022\014\n\004type\030\004 \001(\t\022"
  "\035\n\003arg\030\005 \003(\0132\020.caffe2.Argument\022+\n\rdevice"
  "_option\030\006 \001(\0132\024.caffe2.DeviceOption\022\016\n\006e"
  "ngine\030\007 \001(\t\022\025\n\rcontrol_input\030\010 \003(\t\022\035\n\016is"
  "_gradient_op\030\t \001(\010:\005false\022\022\n\ndebug_info\030"
  "\n \001(\t\022\016\n\006domain\030\013 \001(\t\022\022\n\nop_version\030\014 \001("
  "\003\")\n\rMapFieldEntry\022\013\n\003key\030\001 \002(\t\022\013\n\003val\030\002"
  " \002(\t\"M\n\016BackendOptions\022\024\n\014backend_name\030\001"
  " \002(\t\022%\n\006option\030\002 \003(\0132\025.caffe2.MapFieldEn"
  "try\"u\n\rPartitionInfo\022\014\n\004name\030\001 \002(\t\022\021\n\tde"
  "vice_id\030\002 \003(\005\022\022\n\nextra_info\030\003 \001(\t\022/\n\017bac"
  "kend_options\030\004 \003(\0132\026.caffe2.BackendOptio"
  "ns\"\206\002\n\006NetDef\022\014\n\004name\030\001 \001(\t\022\037\n\002op\030\002 \003(\0132"
  "\023.caffe2.OperatorDef\022\014\n\004type\030\003 \001(\t\022\023\n\013nu"
  "m_workers\030\004 \001(\005\022+\n\rdevice_option\030\005 \001(\0132\024"
  ".caffe2.DeviceOption\022\035\n\003arg\030\006 \003(\0132\020.caff"
  "e2.Argument\022\026\n\016external_input\030\007 \003(\t\022\027\n\017e"
  "xternal_output\030\010 \003(\t\022-\n\016partition_info\030\t"
  " \003(\0132\025.caffe2.PartitionInfo\"\317\002\n\rExecutio"
  "nStep\022\014\n\004name\030\001 \001(\t\022&\n\007substep\030\002 \003(\0132\025.c"
  "affe2.ExecutionStep\022\017\n\007network\030\003 \003(\t\022\020\n\010"
  "num_iter\030\004 \001(\003\022\034\n\020criteria_network\030\005 \001(\t"
  "B\002\030\001\022\022\n\nreport_net\030\007 \001(\t\022\027\n\017report_inter"
  "val\030\010 \001(\005\022\024\n\014run_every_ms\030\013 \001(\003\022\033\n\023concu"
  "rrent_substeps\030\006 \001(\010\022\030\n\020should_stop_blob"
  "\030\t \001(\t\022\021\n\tonly_once\030\n \001(\010\022\030\n\020create_work"
  "space\030\014 \001(\010\022 \n\030num_concurrent_instances\030"
  "\r \001(\005\"g\n\007PlanDef\022\014\n\004name\030\001 \001(\t\022\037\n\007networ"
  "k\030\002 \003(\0132\016.caffe2.NetDef\022-\n\016execution_ste"
  "p\030\003 \003(\0132\025.caffe2.ExecutionStep\"\272\001\n\tBlobP"
  "roto\022\014\n\004name\030\001 \001(\t\022\014\n\004type\030\002 \001(\t\022#\n\006tens"
  "or\030\003 \001(\0132\023.caffe2.TensorProto\022\017\n\007content"
  "\030\004 \001(\014\022%\n\007qtensor\030\005 \001(\0132\024.caffe2.QTensor"
  "Proto\022\032\n\022content_num_chunks\030\006 \001(\005\022\030\n\020con"
  "tent_chunk_id\030\007 \001(\005\"K\n\rDBReaderProto\022\014\n\004"
  "name\030\001 \001(\t\022\016\n\006source\030\002 \001(\t\022\017\n\007db_type\030\003 "
  "\001(\t\022\013\n\003key\030\004 \001(\t\"\325\001\n\030BlobSerializationOp"
  "tions\022\027\n\017blob_name_regex\030\001 \001(\t\022\022\n\nchunk_"
  "size\030\002 \001(\003\022B\n\014float_format\030\003 \001(\0162,.caffe"
  "2.BlobSerializationOptions.FloatFormat\"H"
  "\n\013FloatFormat\022\021\n\rFLOAT_DEFAULT\020\000\022\022\n\016FLOA"
  "T_PROTOBUF\020\001\022\022\n\016FLOAT_BFLOAT16\020\002\"I\n\024Seri"
  "alizationOptions\0221\n\007options\030\001 \003(\0132 .caff"
  "e2.BlobSerializationOptions*\354\001\n\017DeviceTy"
  "peProto\022\r\n\tPROTO_CPU\020\000\022\016\n\nPROTO_CUDA\020\001\022\020"
  "\n\014PROTO_MKLDNN\020\002\022\020\n\014PROTO_OPENGL\020\003\022\020\n\014PR"
  "OTO_OPENCL\020\004\022\017\n\013PROTO_IDEEP\020\005\022\r\n\tPROTO_H"
  "IP\020\006\022\016\n\nPROTO_FPGA\020\007\022\r\n\tPROTO_ORT\020\010\022\r\n\tP"
  "ROTO_XLA\020\t\022\r\n\tPROTO_MPS\020\n\022\'\n#PROTO_COMPI"
  "LE_TIME_MAX_DEVICE_TYPES\020\013"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_caffe2_2fproto_2fcaffe2_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_caffe2_2fproto_2fcaffe2_2eproto_sccs[20] = {
  &scc_info_AOTConfig_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_BlobProto_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_DBReaderProto_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_PlanDef_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_SerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorBoundShapes_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorProtos_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto.base,
  &scc_info_TensorShapes_caffe2_2fproto_2fcaffe2_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_caffe2_2fproto_2fcaffe2_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_caffe2_2fproto_2fcaffe2_2eproto = {
  false, false, descriptor_table_protodef_caffe2_2fproto_2fcaffe2_2eproto, "caffe2/proto/caffe2.proto", 4226,
  &descriptor_table_caffe2_2fproto_2fcaffe2_2eproto_once, descriptor_table_caffe2_2fproto_2fcaffe2_2eproto_sccs, descriptor_table_caffe2_2fproto_2fcaffe2_2eproto_deps, 20, 0,
  schemas, file_default_instances, TableStruct_caffe2_2fproto_2fcaffe2_2eproto::offsets,
  file_level_metadata_caffe2_2fproto_2fcaffe2_2eproto, 22, file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto, file_level_service_descriptors_caffe2_2fproto_2fcaffe2_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_caffe2_2fproto_2fcaffe2_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_caffe2_2fproto_2fcaffe2_2eproto)), true);
namespace caffe2 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorProto_DataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
  return file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto[0];
}
bool TensorProto_DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TensorProto_DataType TensorProto::UNDEFINED;
constexpr TensorProto_DataType TensorProto::FLOAT;
constexpr TensorProto_DataType TensorProto::INT32;
constexpr TensorProto_DataType TensorProto::BYTE;
constexpr TensorProto_DataType TensorProto::STRING;
constexpr TensorProto_DataType TensorProto::BOOL;
constexpr TensorProto_DataType TensorProto::UINT8;
constexpr TensorProto_DataType TensorProto::INT8;
constexpr TensorProto_DataType TensorProto::UINT16;
constexpr TensorProto_DataType TensorProto::INT16;
constexpr TensorProto_DataType TensorProto::INT64;
constexpr TensorProto_DataType TensorProto::FLOAT16;
constexpr TensorProto_DataType TensorProto::DOUBLE;
constexpr TensorProto_DataType TensorProto::ZERO_COLLISION_HASH;
constexpr TensorProto_DataType TensorProto::REBATCHING_BUFFER;
constexpr TensorProto_DataType TensorProto::DataType_MIN;
constexpr TensorProto_DataType TensorProto::DataType_MAX;
constexpr int TensorProto::DataType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorProto_SerializationFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
  return file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto[1];
}
bool TensorProto_SerializationFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TensorProto_SerializationFormat TensorProto::FMT_PROTOBUF;
constexpr TensorProto_SerializationFormat TensorProto::FMT_BFLOAT16;
constexpr TensorProto_SerializationFormat TensorProto::SerializationFormat_MIN;
constexpr TensorProto_SerializationFormat TensorProto::SerializationFormat_MAX;
constexpr int TensorProto::SerializationFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorBoundShape_DimType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
  return file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto[2];
}
bool TensorBoundShape_DimType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TensorBoundShape_DimType TensorBoundShape::UNKNOWN;
constexpr TensorBoundShape_DimType TensorBoundShape::CONSTANT;
constexpr TensorBoundShape_DimType TensorBoundShape::BATCH;
constexpr TensorBoundShape_DimType TensorBoundShape::BATCH_OF_FEATURE_MAX;
constexpr TensorBoundShape_DimType TensorBoundShape::BATCH_OF_FEATURE_MAX_DEFAULT;
constexpr TensorBoundShape_DimType TensorBoundShape::FEATURE_MAX;
constexpr TensorBoundShape_DimType TensorBoundShape::FEATURE_MAX_DEFAULT;
constexpr TensorBoundShape_DimType TensorBoundShape::DimType_MIN;
constexpr TensorBoundShape_DimType TensorBoundShape::DimType_MAX;
constexpr int TensorBoundShape::DimType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlobSerializationOptions_FloatFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
  return file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto[3];
}
bool BlobSerializationOptions_FloatFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr BlobSerializationOptions_FloatFormat BlobSerializationOptions::FLOAT_DEFAULT;
constexpr BlobSerializationOptions_FloatFormat BlobSerializationOptions::FLOAT_PROTOBUF;
constexpr BlobSerializationOptions_FloatFormat BlobSerializationOptions::FLOAT_BFLOAT16;
constexpr BlobSerializationOptions_FloatFormat BlobSerializationOptions::FloatFormat_MIN;
constexpr BlobSerializationOptions_FloatFormat BlobSerializationOptions::FloatFormat_MAX;
constexpr int BlobSerializationOptions::FloatFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceTypeProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
  return file_level_enum_descriptors_caffe2_2fproto_2fcaffe2_2eproto[4];
}
bool DeviceTypeProto_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TensorProto_Segment::InitAsDefaultInstance() {
}
class TensorProto_Segment::_Internal {
 public:
  using HasBits = decltype(std::declval<TensorProto_Segment>()._has_bits_);
  static void set_has_begin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TensorProto_Segment::TensorProto_Segment(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorProto.Segment)
}
TensorProto_Segment::TensorProto_Segment(const TensorProto_Segment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&begin_, &from.begin_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_) -
    reinterpret_cast<char*>(&begin_)) + sizeof(end_));
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorProto.Segment)
}

void TensorProto_Segment::SharedCtor() {
  ::memset(&begin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_) -
      reinterpret_cast<char*>(&begin_)) + sizeof(end_));
}

TensorProto_Segment::~TensorProto_Segment() {
  // @@protoc_insertion_point(destructor:caffe2.TensorProto.Segment)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorProto_Segment::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TensorProto_Segment::ArenaDtor(void* object) {
  TensorProto_Segment* _this = reinterpret_cast< TensorProto_Segment* >(object);
  (void)_this;
}
void TensorProto_Segment::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorProto_Segment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorProto_Segment& TensorProto_Segment::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorProto_Segment_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorProto_Segment::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorProto.Segment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&begin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_) -
        reinterpret_cast<char*>(&begin_)) + sizeof(end_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorProto_Segment::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int64 begin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_begin(&has_bits);
          begin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_end(&has_bits);
          end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorProto_Segment::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorProto.Segment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 begin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_begin(), target);
  }

  // required int64 end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_end(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorProto.Segment)
  return target;
}

size_t TensorProto_Segment::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:caffe2.TensorProto.Segment)
  size_t total_size = 0;

  if (_internal_has_begin()) {
    // required int64 begin = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_begin());
  }

  if (_internal_has_end()) {
    // required int64 end = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_end());
  }

  return total_size;
}
size_t TensorProto_Segment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorProto.Segment)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 begin = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_begin());

    // required int64 end = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_end());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorProto_Segment::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorProto.Segment)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorProto_Segment* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorProto_Segment>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorProto.Segment)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorProto.Segment)
    MergeFrom(*source);
  }
}

void TensorProto_Segment::MergeFrom(const TensorProto_Segment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorProto.Segment)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      begin_ = from.begin_;
    }
    if (cached_has_bits & 0x00000002u) {
      end_ = from.end_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TensorProto_Segment::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorProto.Segment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorProto_Segment::CopyFrom(const TensorProto_Segment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorProto.Segment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorProto_Segment::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TensorProto_Segment::InternalSwap(TensorProto_Segment* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TensorProto_Segment, end_)
      + sizeof(TensorProto_Segment::end_)
      - PROTOBUF_FIELD_OFFSET(TensorProto_Segment, begin_)>(
          reinterpret_cast<char*>(&begin_),
          reinterpret_cast<char*>(&other->begin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorProto_Segment::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TensorProto::InitAsDefaultInstance() {
  ::caffe2::_TensorProto_default_instance_._instance.get_mutable()->device_detail_ = const_cast< ::caffe2::DeviceOption*>(
      ::caffe2::DeviceOption::internal_default_instance());
  ::caffe2::_TensorProto_default_instance_._instance.get_mutable()->segment_ = const_cast< ::caffe2::TensorProto_Segment*>(
      ::caffe2::TensorProto_Segment::internal_default_instance());
}
class TensorProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TensorProto>()._has_bits_);
  static void set_has_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_data_format(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_byte_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_raw_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::caffe2::DeviceOption& device_detail(const TensorProto* msg);
  static void set_has_device_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::caffe2::TensorProto_Segment& segment(const TensorProto* msg);
  static void set_has_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::caffe2::DeviceOption&
TensorProto::_Internal::device_detail(const TensorProto* msg) {
  return *msg->device_detail_;
}
const ::caffe2::TensorProto_Segment&
TensorProto::_Internal::segment(const TensorProto* msg) {
  return *msg->segment_;
}
TensorProto::TensorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  dims_(arena),
  float_data_(arena),
  int32_data_(arena),
  string_data_(arena),
  double_data_(arena),
  int64_data_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorProto)
}
TensorProto::TensorProto(const TensorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      dims_(from.dims_),
      float_data_(from.float_data_),
      int32_data_(from.int32_data_),
      string_data_(from.string_data_),
      double_data_(from.double_data_),
      int64_data_(from.int64_data_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  byte_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_byte_data()) {
    byte_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_byte_data(),
      GetArena());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  raw_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_raw_data()) {
    raw_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_raw_data(),
      GetArena());
  }
  if (from._internal_has_device_detail()) {
    device_detail_ = new ::caffe2::DeviceOption(*from.device_detail_);
  } else {
    device_detail_ = nullptr;
  }
  if (from._internal_has_segment()) {
    segment_ = new ::caffe2::TensorProto_Segment(*from.segment_);
  } else {
    segment_ = nullptr;
  }
  ::memcpy(&data_format_, &from.data_format_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&data_format_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorProto)
}

void TensorProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  byte_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  raw_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&device_detail_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&data_format_) -
      reinterpret_cast<char*>(&device_detail_)) + sizeof(data_format_));
  data_type_ = 1;
}

TensorProto::~TensorProto() {
  // @@protoc_insertion_point(destructor:caffe2.TensorProto)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  byte_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  raw_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete device_detail_;
  if (this != internal_default_instance()) delete segment_;
}

void TensorProto::ArenaDtor(void* object) {
  TensorProto* _this = reinterpret_cast< TensorProto* >(object);
  (void)_this;
}
void TensorProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorProto& TensorProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  float_data_.Clear();
  int32_data_.Clear();
  string_data_.Clear();
  double_data_.Clear();
  int64_data_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      byte_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      raw_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(device_detail_ != nullptr);
      device_detail_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(segment_ != nullptr);
      segment_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    data_format_ = 0u;
    data_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int64 dims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::caffe2::TensorProto_DataType_IsValid(val))) {
            _internal_set_data_type(static_cast<::caffe2::TensorProto_DataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated float float_data = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_float_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29) {
          _internal_add_float_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated int32 int32_data = 4 [packed = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_int32_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32) {
          _internal_add_int32_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes byte_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_byte_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes string_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_string_data();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.TensorProto.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.DeviceOption device_detail = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_detail(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double double_data = 9 [packed = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_double_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73) {
          _internal_add_double_data(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // repeated int64 int64_data = 10 [packed = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_int64_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80) {
          _internal_add_int64_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.TensorProto.Segment segment = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_segment(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes raw_data = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_raw_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 data_format = 15 [default = 0];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_data_format(&has_bits);
          data_format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  for (int i = 0, n = this->_internal_dims_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_dims(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // repeated float float_data = 3 [packed = true];
  if (this->_internal_float_data_size() > 0) {
    target = stream->WriteFixedPacked(3, _internal_float_data(), target);
  }

  // repeated int32 int32_data = 4 [packed = true];
  {
    int byte_size = _int32_data_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_int32_data(), byte_size, target);
    }
  }

  // optional bytes byte_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_byte_data(), target);
  }

  // repeated bytes string_data = 6;
  for (int i = 0, n = this->_internal_string_data_size(); i < n; i++) {
    const auto& s = this->_internal_string_data(i);
    target = stream->WriteBytes(6, s, target);
  }

  // optional string name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.TensorProto.name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_name(), target);
  }

  // optional .caffe2.DeviceOption device_detail = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::device_detail(this), target, stream);
  }

  // repeated double double_data = 9 [packed = true];
  if (this->_internal_double_data_size() > 0) {
    target = stream->WriteFixedPacked(9, _internal_double_data(), target);
  }

  // repeated int64 int64_data = 10 [packed = true];
  {
    int byte_size = _int64_data_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          10, _internal_int64_data(), byte_size, target);
    }
  }

  // optional .caffe2.TensorProto.Segment segment = 11;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::segment(this), target, stream);
  }

  // optional bytes raw_data = 13;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_raw_data(), target);
  }

  // optional uint32 data_format = 15 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->_internal_data_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorProto)
  return target;
}

size_t TensorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_dims_size());
    total_size += data_size;
  }

  // repeated float float_data = 3 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_float_data_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _float_data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 int32_data = 4 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->int32_data_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _int32_data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated bytes string_data = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(string_data_.size());
  for (int i = 0, n = string_data_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      string_data_.Get(i));
  }

  // repeated double double_data = 9 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_double_data_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _double_data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 int64_data = 10 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->int64_data_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _int64_data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes byte_data = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_byte_data());
    }

    // optional string name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes raw_data = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_data());
    }

    // optional .caffe2.DeviceOption device_detail = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_detail_);
    }

    // optional .caffe2.TensorProto.Segment segment = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *segment_);
    }

    // optional uint32 data_format = 15 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_data_format());
    }

    // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorProto)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorProto)
    MergeFrom(*source);
  }
}

void TensorProto::MergeFrom(const TensorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  float_data_.MergeFrom(from.float_data_);
  int32_data_.MergeFrom(from.int32_data_);
  string_data_.MergeFrom(from.string_data_);
  double_data_.MergeFrom(from.double_data_);
  int64_data_.MergeFrom(from.int64_data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_byte_data(from._internal_byte_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_raw_data(from._internal_raw_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_device_detail()->::caffe2::DeviceOption::MergeFrom(from._internal_device_detail());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_segment()->::caffe2::TensorProto_Segment::MergeFrom(from._internal_segment());
    }
    if (cached_has_bits & 0x00000020u) {
      data_format_ = from.data_format_;
    }
    if (cached_has_bits & 0x00000040u) {
      data_type_ = from.data_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TensorProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorProto::CopyFrom(const TensorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorProto::IsInitialized() const {
  if (_internal_has_segment()) {
    if (!segment_->IsInitialized()) return false;
  }
  return true;
}

void TensorProto::InternalSwap(TensorProto* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dims_.InternalSwap(&other->dims_);
  float_data_.InternalSwap(&other->float_data_);
  int32_data_.InternalSwap(&other->int32_data_);
  string_data_.InternalSwap(&other->string_data_);
  double_data_.InternalSwap(&other->double_data_);
  int64_data_.InternalSwap(&other->int64_data_);
  byte_data_.Swap(&other->byte_data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  raw_data_.Swap(&other->raw_data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TensorProto, data_format_)
      + sizeof(TensorProto::data_format_)
      - PROTOBUF_FIELD_OFFSET(TensorProto, device_detail_)>(
          reinterpret_cast<char*>(&device_detail_),
          reinterpret_cast<char*>(&other->device_detail_));
  swap(data_type_, other->data_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void QTensorProto::InitAsDefaultInstance() {
}
class QTensorProto::_Internal {
 public:
  using HasBits = decltype(std::declval<QTensorProto>()._has_bits_);
  static void set_has_precision(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_signed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_axis(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_multiparam(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001e) ^ 0x0000001e) != 0;
  }
};

QTensorProto::QTensorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  dims_(arena),
  data_(arena),
  scales_(arena),
  biases_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.QTensorProto)
}
QTensorProto::QTensorProto(const QTensorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      dims_(from.dims_),
      data_(from.data_),
      scales_(from.scales_),
      biases_(from.biases_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  ::memcpy(&scale_, &from.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&scale_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:caffe2.QTensorProto)
}

void QTensorProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&scale_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&axis_) -
      reinterpret_cast<char*>(&scale_)) + sizeof(axis_));
  data_type_ = 2;
}

QTensorProto::~QTensorProto() {
  // @@protoc_insertion_point(destructor:caffe2.QTensorProto)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void QTensorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void QTensorProto::ArenaDtor(void* object) {
  QTensorProto* _this = reinterpret_cast< QTensorProto* >(object);
  (void)_this;
}
void QTensorProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void QTensorProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const QTensorProto& QTensorProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_QTensorProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void QTensorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.QTensorProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  data_.Clear();
  scales_.Clear();
  biases_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&axis_) -
        reinterpret_cast<char*>(&scale_)) + sizeof(axis_));
    data_type_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QTensorProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int64 dims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 precision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_precision(&has_bits);
          precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required double scale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required double bias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          _Internal::set_has_bias(&has_bits);
          bias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // required bool is_signed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_is_signed(&has_bits);
          is_signed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 data = 6 [packed = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_data(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48) {
          _internal_add_data(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.QTensorProto.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::caffe2::TensorProto_DataType_IsValid(val))) {
            _internal_set_data_type(static_cast<::caffe2::TensorProto_DataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated double scales = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 73)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_scales(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<73>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_scales(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated double biases = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_biases(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<81>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_biases(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 axis = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_axis(&has_bits);
          axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_multiparam = 12 [default = false];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_is_multiparam(&has_bits);
          is_multiparam_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* QTensorProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.QTensorProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  for (int i = 0, n = this->_internal_dims_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_dims(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // required int32 precision = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_precision(), target);
  }

  // required double scale = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_scale(), target);
  }

  // required double bias = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_bias(), target);
  }

  // required bool is_signed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_signed(), target);
  }

  // repeated int32 data = 6 [packed = true];
  {
    int byte_size = _data_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          6, _internal_data(), byte_size, target);
    }
  }

  // optional string name = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.QTensorProto.name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_name(), target);
  }

  // optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_data_type(), target);
  }

  // repeated double scales = 9;
  for (int i = 0, n = this->_internal_scales_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(9, this->_internal_scales(i), target);
  }

  // repeated double biases = 10;
  for (int i = 0, n = this->_internal_biases_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(10, this->_internal_biases(i), target);
  }

  // optional int32 axis = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_axis(), target);
  }

  // optional bool is_multiparam = 12 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_multiparam(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.QTensorProto)
  return target;
}

size_t QTensorProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:caffe2.QTensorProto)
  size_t total_size = 0;

  if (_internal_has_scale()) {
    // required double scale = 3;
    total_size += 1 + 8;
  }

  if (_internal_has_bias()) {
    // required double bias = 4;
    total_size += 1 + 8;
  }

  if (_internal_has_precision()) {
    // required int32 precision = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_precision());
  }

  if (_internal_has_is_signed()) {
    // required bool is_signed = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t QTensorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.QTensorProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001e) ^ 0x0000001e) == 0) {  // All required fields are present.
    // required double scale = 3;
    total_size += 1 + 8;

    // required double bias = 4;
    total_size += 1 + 8;

    // required int32 precision = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_precision());

    // required bool is_signed = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_dims_size());
    total_size += data_size;
  }

  // repeated int32 data = 6 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->data_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _data_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated double scales = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_scales_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_scales_size());
    total_size += data_size;
  }

  // repeated double biases = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_biases_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_biases_size());
    total_size += data_size;
  }

  // optional string name = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (cached_has_bits & 0x000000e0u) {
    // optional bool is_multiparam = 12 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int32 axis = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_axis());
    }

    // optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QTensorProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.QTensorProto)
  GOOGLE_DCHECK_NE(&from, this);
  const QTensorProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<QTensorProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.QTensorProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.QTensorProto)
    MergeFrom(*source);
  }
}

void QTensorProto::MergeFrom(const QTensorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.QTensorProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  data_.MergeFrom(from.data_);
  scales_.MergeFrom(from.scales_);
  biases_.MergeFrom(from.biases_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000004u) {
      bias_ = from.bias_;
    }
    if (cached_has_bits & 0x00000008u) {
      precision_ = from.precision_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_signed_ = from.is_signed_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_multiparam_ = from.is_multiparam_;
    }
    if (cached_has_bits & 0x00000040u) {
      axis_ = from.axis_;
    }
    if (cached_has_bits & 0x00000080u) {
      data_type_ = from.data_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void QTensorProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.QTensorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QTensorProto::CopyFrom(const QTensorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.QTensorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QTensorProto::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void QTensorProto::InternalSwap(QTensorProto* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dims_.InternalSwap(&other->dims_);
  data_.InternalSwap(&other->data_);
  scales_.InternalSwap(&other->scales_);
  biases_.InternalSwap(&other->biases_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QTensorProto, axis_)
      + sizeof(QTensorProto::axis_)
      - PROTOBUF_FIELD_OFFSET(QTensorProto, scale_)>(
          reinterpret_cast<char*>(&scale_),
          reinterpret_cast<char*>(&other->scale_));
  swap(data_type_, other->data_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata QTensorProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TensorProtos::InitAsDefaultInstance() {
}
class TensorProtos::_Internal {
 public:
};

TensorProtos::TensorProtos(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  protos_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorProtos)
}
TensorProtos::TensorProtos(const TensorProtos& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      protos_(from.protos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorProtos)
}

void TensorProtos::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TensorProtos_caffe2_2fproto_2fcaffe2_2eproto.base);
}

TensorProtos::~TensorProtos() {
  // @@protoc_insertion_point(destructor:caffe2.TensorProtos)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorProtos::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TensorProtos::ArenaDtor(void* object) {
  TensorProtos* _this = reinterpret_cast< TensorProtos* >(object);
  (void)_this;
}
void TensorProtos::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorProtos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorProtos& TensorProtos::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorProtos_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorProtos::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorProtos)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  protos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorProtos::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .caffe2.TensorProto protos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_protos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorProtos::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorProtos)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .caffe2.TensorProto protos = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_protos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_protos(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorProtos)
  return target;
}

size_t TensorProtos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorProtos)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.TensorProto protos = 1;
  total_size += 1UL * this->_internal_protos_size();
  for (const auto& msg : this->protos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorProtos::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorProtos)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorProtos* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorProtos>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorProtos)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorProtos)
    MergeFrom(*source);
  }
}

void TensorProtos::MergeFrom(const TensorProtos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorProtos)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  protos_.MergeFrom(from.protos_);
}

void TensorProtos::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorProtos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorProtos::CopyFrom(const TensorProtos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorProtos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorProtos::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(protos_)) return false;
  return true;
}

void TensorProtos::InternalSwap(TensorProtos* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  protos_.InternalSwap(&other->protos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorProtos::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TensorShape::InitAsDefaultInstance() {
}
class TensorShape::_Internal {
 public:
  using HasBits = decltype(std::declval<TensorShape>()._has_bits_);
  static void set_has_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unknown_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TensorShape::TensorShape(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  dims_(arena),
  unknown_dims_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorShape)
}
TensorShape::TensorShape(const TensorShape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      dims_(from.dims_),
      unknown_dims_(from.unknown_dims_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  ::memcpy(&unknown_shape_, &from.unknown_shape_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&unknown_shape_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorShape)
}

void TensorShape::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  unknown_shape_ = false;
  data_type_ = 1;
}

TensorShape::~TensorShape() {
  // @@protoc_insertion_point(destructor:caffe2.TensorShape)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorShape::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TensorShape::ArenaDtor(void* object) {
  TensorShape* _this = reinterpret_cast< TensorShape* >(object);
  (void)_this;
}
void TensorShape::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorShape::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorShape& TensorShape::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorShape_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorShape::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  unknown_dims_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    unknown_shape_ = false;
    data_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorShape::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated int64 dims = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::caffe2::TensorProto_DataType_IsValid(val))) {
            _internal_set_data_type(static_cast<::caffe2::TensorProto_DataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated int32 unknown_dims = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_unknown_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_unknown_dims(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool unknown_shape = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_unknown_shape(&has_bits);
          unknown_shape_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.TensorShape.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorShape::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  for (int i = 0, n = this->_internal_dims_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_dims(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // repeated int32 unknown_dims = 3;
  for (int i = 0, n = this->_internal_unknown_dims_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_unknown_dims(i), target);
  }

  // optional bool unknown_shape = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_unknown_shape(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.TensorShape.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorShape)
  return target;
}

size_t TensorShape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorShape)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->dims_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_dims_size());
    total_size += data_size;
  }

  // repeated int32 unknown_dims = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->unknown_dims_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_unknown_dims_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool unknown_shape = 4 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorShape::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorShape)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorShape* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorShape>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorShape)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorShape)
    MergeFrom(*source);
  }
}

void TensorShape::MergeFrom(const TensorShape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorShape)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  unknown_dims_.MergeFrom(from.unknown_dims_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      unknown_shape_ = from.unknown_shape_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_type_ = from.data_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TensorShape::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorShape::CopyFrom(const TensorShape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorShape::IsInitialized() const {
  return true;
}

void TensorShape::InternalSwap(TensorShape* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dims_.InternalSwap(&other->dims_);
  unknown_dims_.InternalSwap(&other->unknown_dims_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(unknown_shape_, other->unknown_shape_);
  swap(data_type_, other->data_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorShape::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TensorShapes::InitAsDefaultInstance() {
}
class TensorShapes::_Internal {
 public:
};

TensorShapes::TensorShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  shapes_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorShapes)
}
TensorShapes::TensorShapes(const TensorShapes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      shapes_(from.shapes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorShapes)
}

void TensorShapes::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TensorShapes_caffe2_2fproto_2fcaffe2_2eproto.base);
}

TensorShapes::~TensorShapes() {
  // @@protoc_insertion_point(destructor:caffe2.TensorShapes)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorShapes::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TensorShapes::ArenaDtor(void* object) {
  TensorShapes* _this = reinterpret_cast< TensorShapes* >(object);
  (void)_this;
}
void TensorShapes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorShapes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorShapes& TensorShapes::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorShapes_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorShapes::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorShapes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shapes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorShapes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .caffe2.TensorShape shapes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shapes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorShapes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorShapes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .caffe2.TensorShape shapes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_shapes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_shapes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorShapes)
  return target;
}

size_t TensorShapes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorShapes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.TensorShape shapes = 1;
  total_size += 1UL * this->_internal_shapes_size();
  for (const auto& msg : this->shapes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorShapes::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorShapes)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorShapes* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorShapes>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorShapes)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorShapes)
    MergeFrom(*source);
  }
}

void TensorShapes::MergeFrom(const TensorShapes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorShapes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shapes_.MergeFrom(from.shapes_);
}

void TensorShapes::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorShapes::CopyFrom(const TensorShapes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorShapes::IsInitialized() const {
  return true;
}

void TensorShapes::InternalSwap(TensorShapes* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  shapes_.InternalSwap(&other->shapes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorShapes::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TensorBoundShape::InitAsDefaultInstance() {
  ::caffe2::_TensorBoundShape_default_instance_._instance.get_mutable()->shape_ = const_cast< ::caffe2::TensorShape*>(
      ::caffe2::TensorShape::internal_default_instance());
}
class TensorBoundShape::_Internal {
 public:
  using HasBits = decltype(std::declval<TensorBoundShape>()._has_bits_);
  static const ::caffe2::TensorShape& shape(const TensorBoundShape* msg);
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shape_is_final(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::caffe2::TensorShape&
TensorBoundShape::_Internal::shape(const TensorBoundShape* msg) {
  return *msg->shape_;
}
TensorBoundShape::TensorBoundShape(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  dim_type_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorBoundShape)
}
TensorBoundShape::TensorBoundShape(const TensorBoundShape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      dim_type_(from.dim_type_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_shape()) {
    shape_ = new ::caffe2::TensorShape(*from.shape_);
  } else {
    shape_ = nullptr;
  }
  shape_is_final_ = from.shape_is_final_;
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorBoundShape)
}

void TensorBoundShape::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&shape_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&shape_is_final_) -
      reinterpret_cast<char*>(&shape_)) + sizeof(shape_is_final_));
}

TensorBoundShape::~TensorBoundShape() {
  // @@protoc_insertion_point(destructor:caffe2.TensorBoundShape)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorBoundShape::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete shape_;
}

void TensorBoundShape::ArenaDtor(void* object) {
  TensorBoundShape* _this = reinterpret_cast< TensorBoundShape* >(object);
  (void)_this;
}
void TensorBoundShape::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorBoundShape::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorBoundShape& TensorBoundShape::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorBoundShape_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorBoundShape::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorBoundShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dim_type_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(shape_ != nullptr);
      shape_->Clear();
    }
  }
  shape_is_final_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorBoundShape::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .caffe2.TensorShape shape = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.TensorBoundShape.DimType dim_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::caffe2::TensorBoundShape_DimType_IsValid(val))) {
              _internal_add_dim_type(static_cast<::caffe2::TensorBoundShape_DimType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_dim_type(), ptr, ctx, ::caffe2::TensorBoundShape_DimType_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.TensorBoundShape.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool shape_is_final = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_shape_is_final(&has_bits);
          shape_is_final_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorBoundShape::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorBoundShape)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .caffe2.TensorShape shape = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::shape(this), target, stream);
  }

  // repeated .caffe2.TensorBoundShape.DimType dim_type = 2;
  for (int i = 0, n = this->_internal_dim_type_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        2, this->_internal_dim_type(i), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.TensorBoundShape.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional bool shape_is_final = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_shape_is_final(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorBoundShape)
  return target;
}

size_t TensorBoundShape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorBoundShape)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.TensorBoundShape.DimType dim_type = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_dim_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_dim_type(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .caffe2.TensorShape shape = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shape_);
    }

    // optional bool shape_is_final = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorBoundShape::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorBoundShape)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorBoundShape* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorBoundShape>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorBoundShape)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorBoundShape)
    MergeFrom(*source);
  }
}

void TensorBoundShape::MergeFrom(const TensorBoundShape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorBoundShape)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dim_type_.MergeFrom(from.dim_type_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_shape()->::caffe2::TensorShape::MergeFrom(from._internal_shape());
    }
    if (cached_has_bits & 0x00000004u) {
      shape_is_final_ = from.shape_is_final_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TensorBoundShape::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorBoundShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorBoundShape::CopyFrom(const TensorBoundShape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorBoundShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorBoundShape::IsInitialized() const {
  return true;
}

void TensorBoundShape::InternalSwap(TensorBoundShape* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  dim_type_.InternalSwap(&other->dim_type_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TensorBoundShape, shape_is_final_)
      + sizeof(TensorBoundShape::shape_is_final_)
      - PROTOBUF_FIELD_OFFSET(TensorBoundShape, shape_)>(
          reinterpret_cast<char*>(&shape_),
          reinterpret_cast<char*>(&other->shape_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorBoundShape::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TensorBoundShapes::InitAsDefaultInstance() {
}
class TensorBoundShapes::_Internal {
 public:
  using HasBits = decltype(std::declval<TensorBoundShapes>()._has_bits_);
  static void set_has_max_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_feature_len(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TensorBoundShapes::TensorBoundShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  shapes_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.TensorBoundShapes)
}
TensorBoundShapes::TensorBoundShapes(const TensorBoundShapes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      shapes_(from.shapes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&max_batch_size_, &from.max_batch_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_feature_len_) -
    reinterpret_cast<char*>(&max_batch_size_)) + sizeof(max_feature_len_));
  // @@protoc_insertion_point(copy_constructor:caffe2.TensorBoundShapes)
}

void TensorBoundShapes::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TensorBoundShapes_caffe2_2fproto_2fcaffe2_2eproto.base);
  ::memset(&max_batch_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_feature_len_) -
      reinterpret_cast<char*>(&max_batch_size_)) + sizeof(max_feature_len_));
}

TensorBoundShapes::~TensorBoundShapes() {
  // @@protoc_insertion_point(destructor:caffe2.TensorBoundShapes)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TensorBoundShapes::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TensorBoundShapes::ArenaDtor(void* object) {
  TensorBoundShapes* _this = reinterpret_cast< TensorBoundShapes* >(object);
  (void)_this;
}
void TensorBoundShapes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TensorBoundShapes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TensorBoundShapes& TensorBoundShapes::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TensorBoundShapes_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void TensorBoundShapes::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.TensorBoundShapes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shapes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&max_batch_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_feature_len_) -
        reinterpret_cast<char*>(&max_batch_size_)) + sizeof(max_feature_len_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TensorBoundShapes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .caffe2.TensorBoundShape shapes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shapes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int64 max_batch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_batch_size(&has_bits);
          max_batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 max_feature_len = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_feature_len(&has_bits);
          max_feature_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TensorBoundShapes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.TensorBoundShapes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .caffe2.TensorBoundShape shapes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_shapes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_shapes(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int64 max_batch_size = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_max_batch_size(), target);
  }

  // optional int64 max_feature_len = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_max_feature_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.TensorBoundShapes)
  return target;
}

size_t TensorBoundShapes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.TensorBoundShapes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.TensorBoundShape shapes = 1;
  total_size += 1UL * this->_internal_shapes_size();
  for (const auto& msg : this->shapes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 max_batch_size = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_max_batch_size());
    }

    // optional int64 max_feature_len = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_max_feature_len());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TensorBoundShapes::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.TensorBoundShapes)
  GOOGLE_DCHECK_NE(&from, this);
  const TensorBoundShapes* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TensorBoundShapes>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.TensorBoundShapes)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.TensorBoundShapes)
    MergeFrom(*source);
  }
}

void TensorBoundShapes::MergeFrom(const TensorBoundShapes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.TensorBoundShapes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shapes_.MergeFrom(from.shapes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      max_batch_size_ = from.max_batch_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_feature_len_ = from.max_feature_len_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TensorBoundShapes::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.TensorBoundShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorBoundShapes::CopyFrom(const TensorBoundShapes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.TensorBoundShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorBoundShapes::IsInitialized() const {
  return true;
}

void TensorBoundShapes::InternalSwap(TensorBoundShapes* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  shapes_.InternalSwap(&other->shapes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TensorBoundShapes, max_feature_len_)
      + sizeof(TensorBoundShapes::max_feature_len_)
      - PROTOBUF_FIELD_OFFSET(TensorBoundShapes, max_batch_size_)>(
          reinterpret_cast<char*>(&max_batch_size_),
          reinterpret_cast<char*>(&other->max_batch_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TensorBoundShapes::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AOTConfig::InitAsDefaultInstance() {
}
class AOTConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AOTConfig>()._has_bits_);
  static void set_has_max_batch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_seq_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_in_batch_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_onnxifi_blacklist_ops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_onnxifi_min_ops(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

AOTConfig::AOTConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.AOTConfig)
}
AOTConfig::AOTConfig(const AOTConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  onnxifi_blacklist_ops_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_onnxifi_blacklist_ops()) {
    onnxifi_blacklist_ops_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_onnxifi_blacklist_ops(),
      GetArena());
  }
  ::memcpy(&max_batch_size_, &from.max_batch_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&onnxifi_min_ops_) -
    reinterpret_cast<char*>(&max_batch_size_)) + sizeof(onnxifi_min_ops_));
  // @@protoc_insertion_point(copy_constructor:caffe2.AOTConfig)
}

void AOTConfig::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AOTConfig_caffe2_2fproto_2fcaffe2_2eproto.base);
  onnxifi_blacklist_ops_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&max_batch_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&onnxifi_min_ops_) -
      reinterpret_cast<char*>(&max_batch_size_)) + sizeof(onnxifi_min_ops_));
}

AOTConfig::~AOTConfig() {
  // @@protoc_insertion_point(destructor:caffe2.AOTConfig)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AOTConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  onnxifi_blacklist_ops_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AOTConfig::ArenaDtor(void* object) {
  AOTConfig* _this = reinterpret_cast< AOTConfig* >(object);
  (void)_this;
}
void AOTConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AOTConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AOTConfig& AOTConfig::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AOTConfig_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void AOTConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.AOTConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    onnxifi_blacklist_ops_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&max_batch_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&onnxifi_min_ops_) -
        reinterpret_cast<char*>(&max_batch_size_)) + sizeof(onnxifi_min_ops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AOTConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int64 max_batch_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_max_batch_size(&has_bits);
          max_batch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 max_seq_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_seq_size(&has_bits);
          max_seq_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool in_batch_broadcast = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_in_batch_broadcast(&has_bits);
          in_batch_broadcast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string onnxifi_blacklist_ops = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_onnxifi_blacklist_ops();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.AOTConfig.onnxifi_blacklist_ops");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 onnxifi_min_ops = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_onnxifi_min_ops(&has_bits);
          onnxifi_min_ops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AOTConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.AOTConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 max_batch_size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_max_batch_size(), target);
  }

  // required int64 max_seq_size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_max_seq_size(), target);
  }

  // required bool in_batch_broadcast = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_in_batch_broadcast(), target);
  }

  // optional string onnxifi_blacklist_ops = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_onnxifi_blacklist_ops().data(), static_cast<int>(this->_internal_onnxifi_blacklist_ops().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.AOTConfig.onnxifi_blacklist_ops");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_onnxifi_blacklist_ops(), target);
  }

  // optional int32 onnxifi_min_ops = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_onnxifi_min_ops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.AOTConfig)
  return target;
}

size_t AOTConfig::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:caffe2.AOTConfig)
  size_t total_size = 0;

  if (_internal_has_max_batch_size()) {
    // required int64 max_batch_size = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_max_batch_size());
  }

  if (_internal_has_max_seq_size()) {
    // required int64 max_seq_size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_max_seq_size());
  }

  if (_internal_has_in_batch_broadcast()) {
    // required bool in_batch_broadcast = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t AOTConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.AOTConfig)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required int64 max_batch_size = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_max_batch_size());

    // required int64 max_seq_size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_max_seq_size());

    // required bool in_batch_broadcast = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string onnxifi_blacklist_ops = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_onnxifi_blacklist_ops());
  }

  // optional int32 onnxifi_min_ops = 5;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_onnxifi_min_ops());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AOTConfig::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.AOTConfig)
  GOOGLE_DCHECK_NE(&from, this);
  const AOTConfig* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AOTConfig>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.AOTConfig)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.AOTConfig)
    MergeFrom(*source);
  }
}

void AOTConfig::MergeFrom(const AOTConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.AOTConfig)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_onnxifi_blacklist_ops(from._internal_onnxifi_blacklist_ops());
    }
    if (cached_has_bits & 0x00000002u) {
      max_batch_size_ = from.max_batch_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_seq_size_ = from.max_seq_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      in_batch_broadcast_ = from.in_batch_broadcast_;
    }
    if (cached_has_bits & 0x00000010u) {
      onnxifi_min_ops_ = from.onnxifi_min_ops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void AOTConfig::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.AOTConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AOTConfig::CopyFrom(const AOTConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.AOTConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AOTConfig::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AOTConfig::InternalSwap(AOTConfig* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  onnxifi_blacklist_ops_.Swap(&other->onnxifi_blacklist_ops_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AOTConfig, onnxifi_min_ops_)
      + sizeof(AOTConfig::onnxifi_min_ops_)
      - PROTOBUF_FIELD_OFFSET(AOTConfig, max_batch_size_)>(
          reinterpret_cast<char*>(&max_batch_size_),
          reinterpret_cast<char*>(&other->max_batch_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AOTConfig::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Argument::InitAsDefaultInstance() {
  ::caffe2::_Argument_default_instance_._instance.get_mutable()->t_ = const_cast< ::caffe2::TensorProto*>(
      ::caffe2::TensorProto::internal_default_instance());
  ::caffe2::_Argument_default_instance_._instance.get_mutable()->n_ = const_cast< ::caffe2::NetDef*>(
      ::caffe2::NetDef::internal_default_instance());
}
class Argument::_Internal {
 public:
  using HasBits = decltype(std::declval<Argument>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_f(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_i(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_s(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::caffe2::TensorProto& t(const Argument* msg);
  static void set_has_t(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::caffe2::NetDef& n(const Argument* msg);
  static void set_has_n(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::caffe2::TensorProto&
Argument::_Internal::t(const Argument* msg) {
  return *msg->t_;
}
const ::caffe2::NetDef&
Argument::_Internal::n(const Argument* msg) {
  return *msg->n_;
}
Argument::Argument(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  floats_(arena),
  ints_(arena),
  strings_(arena),
  nets_(arena),
  tensors_(arena),
  qtensors_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.Argument)
}
Argument::Argument(const Argument& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      floats_(from.floats_),
      ints_(from.ints_),
      strings_(from.strings_),
      nets_(from.nets_),
      tensors_(from.tensors_),
      qtensors_(from.qtensors_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_s()) {
    s_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_s(),
      GetArena());
  }
  if (from._internal_has_n()) {
    n_ = new ::caffe2::NetDef(*from.n_);
  } else {
    n_ = nullptr;
  }
  if (from._internal_has_t()) {
    t_ = new ::caffe2::TensorProto(*from.t_);
  } else {
    t_ = nullptr;
  }
  ::memcpy(&i_, &from.i_,
    static_cast<size_t>(reinterpret_cast<char*>(&f_) -
    reinterpret_cast<char*>(&i_)) + sizeof(f_));
  // @@protoc_insertion_point(copy_constructor:caffe2.Argument)
}

void Argument::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  s_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&n_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&f_) -
      reinterpret_cast<char*>(&n_)) + sizeof(f_));
}

Argument::~Argument() {
  // @@protoc_insertion_point(destructor:caffe2.Argument)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Argument::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  s_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete n_;
  if (this != internal_default_instance()) delete t_;
}

void Argument::ArenaDtor(void* object) {
  Argument* _this = reinterpret_cast< Argument* >(object);
  (void)_this;
}
void Argument::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Argument::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Argument& Argument::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void Argument::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.Argument)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  floats_.Clear();
  ints_.Clear();
  strings_.Clear();
  nets_.Clear();
  tensors_.Clear();
  qtensors_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      s_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(n_ != nullptr);
      n_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(t_ != nullptr);
      t_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&i_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&f_) -
        reinterpret_cast<char*>(&i_)) + sizeof(f_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Argument::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.Argument.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float f = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_f(&has_bits);
          f_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int64 i = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_i(&has_bits);
          i_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes s = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_s();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated float floats = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_floats(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<45>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_floats(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int64 ints = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ints(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ints(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes strings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_strings();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .caffe2.NetDef n = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_n(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.NetDef nets = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .caffe2.TensorProto t = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_t(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.TensorProto tensors = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tensors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.QTensorProto qtensors = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_qtensors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Argument::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.Argument)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.Argument.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional float f = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_f(), target);
  }

  // optional int64 i = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_i(), target);
  }

  // optional bytes s = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_s(), target);
  }

  // repeated float floats = 5;
  for (int i = 0, n = this->_internal_floats_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_floats(i), target);
  }

  // repeated int64 ints = 6;
  for (int i = 0, n = this->_internal_ints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_ints(i), target);
  }

  // repeated bytes strings = 7;
  for (int i = 0, n = this->_internal_strings_size(); i < n; i++) {
    const auto& s = this->_internal_strings(i);
    target = stream->WriteBytes(7, s, target);
  }

  // optional .caffe2.NetDef n = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::n(this), target, stream);
  }

  // repeated .caffe2.NetDef nets = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_nets(i), target, stream);
  }

  // optional .caffe2.TensorProto t = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::t(this), target, stream);
  }

  // repeated .caffe2.TensorProto tensors = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tensors_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_tensors(i), target, stream);
  }

  // repeated .caffe2.QTensorProto qtensors = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_qtensors_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_qtensors(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.Argument)
  return target;
}

size_t Argument::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.Argument)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float floats = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_floats_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_floats_size());
    total_size += data_size;
  }

  // repeated int64 ints = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->ints_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ints_size());
    total_size += data_size;
  }

  // repeated bytes strings = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(strings_.size());
  for (int i = 0, n = strings_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      strings_.Get(i));
  }

  // repeated .caffe2.NetDef nets = 9;
  total_size += 1UL * this->_internal_nets_size();
  for (const auto& msg : this->nets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .caffe2.TensorProto tensors = 11;
  total_size += 1UL * this->_internal_tensors_size();
  for (const auto& msg : this->tensors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .caffe2.QTensorProto qtensors = 12;
  total_size += 1UL * this->_internal_qtensors_size();
  for (const auto& msg : this->qtensors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes s = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_s());
    }

    // optional .caffe2.NetDef n = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *n_);
    }

    // optional .caffe2.TensorProto t = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *t_);
    }

    // optional int64 i = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_i());
    }

    // optional float f = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Argument::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.Argument)
  GOOGLE_DCHECK_NE(&from, this);
  const Argument* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Argument>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.Argument)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.Argument)
    MergeFrom(*source);
  }
}

void Argument::MergeFrom(const Argument& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.Argument)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  floats_.MergeFrom(from.floats_);
  ints_.MergeFrom(from.ints_);
  strings_.MergeFrom(from.strings_);
  nets_.MergeFrom(from.nets_);
  tensors_.MergeFrom(from.tensors_);
  qtensors_.MergeFrom(from.qtensors_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_s(from._internal_s());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_n()->::caffe2::NetDef::MergeFrom(from._internal_n());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_t()->::caffe2::TensorProto::MergeFrom(from._internal_t());
    }
    if (cached_has_bits & 0x00000010u) {
      i_ = from.i_;
    }
    if (cached_has_bits & 0x00000020u) {
      f_ = from.f_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Argument::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.Argument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Argument::CopyFrom(const Argument& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.Argument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Argument::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(nets_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(tensors_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(qtensors_)) return false;
  if (_internal_has_n()) {
    if (!n_->IsInitialized()) return false;
  }
  if (_internal_has_t()) {
    if (!t_->IsInitialized()) return false;
  }
  return true;
}

void Argument::InternalSwap(Argument* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  floats_.InternalSwap(&other->floats_);
  ints_.InternalSwap(&other->ints_);
  strings_.InternalSwap(&other->strings_);
  nets_.InternalSwap(&other->nets_);
  tensors_.InternalSwap(&other->tensors_);
  qtensors_.InternalSwap(&other->qtensors_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  s_.Swap(&other->s_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Argument, f_)
      + sizeof(Argument::f_)
      - PROTOBUF_FIELD_OFFSET(Argument, n_)>(
          reinterpret_cast<char*>(&n_),
          reinterpret_cast<char*>(&other->n_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Argument::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DeviceOption::InitAsDefaultInstance() {
}
class DeviceOption::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceOption>()._has_bits_);
  static void set_has_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_node_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_numa_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DeviceOption::DeviceOption(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  extra_info_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.DeviceOption)
}
DeviceOption::DeviceOption(const DeviceOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      extra_info_(from.extra_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  node_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_node_name()) {
    node_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_node_name(),
      GetArena());
  }
  ::memcpy(&device_type_, &from.device_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&numa_node_id_) -
    reinterpret_cast<char*>(&device_type_)) + sizeof(numa_node_id_));
  // @@protoc_insertion_point(copy_constructor:caffe2.DeviceOption)
}

void DeviceOption::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto.base);
  node_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&device_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&numa_node_id_) -
      reinterpret_cast<char*>(&device_type_)) + sizeof(numa_node_id_));
}

DeviceOption::~DeviceOption() {
  // @@protoc_insertion_point(destructor:caffe2.DeviceOption)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DeviceOption::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  node_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DeviceOption::ArenaDtor(void* object) {
  DeviceOption* _this = reinterpret_cast< DeviceOption* >(object);
  (void)_this;
}
void DeviceOption::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeviceOption::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DeviceOption& DeviceOption::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DeviceOption_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void DeviceOption::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.DeviceOption)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  extra_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    node_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&device_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&numa_node_id_) -
        reinterpret_cast<char*>(&device_type_)) + sizeof(numa_node_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeviceOption::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 device_type = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_device_type(&has_bits);
          device_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 random_seed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_random_seed(&has_bits);
          random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string node_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_node_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.DeviceOption.node_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 numa_node_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_numa_node_id(&has_bits);
          numa_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string extra_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_extra_info();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.DeviceOption.extra_info");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DeviceOption::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.DeviceOption)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 device_type = 1 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_device_type(), target);
  }

  // optional int32 device_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_device_id(), target);
  }

  // optional uint32 random_seed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_random_seed(), target);
  }

  // optional string node_name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_node_name().data(), static_cast<int>(this->_internal_node_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.DeviceOption.node_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_node_name(), target);
  }

  // optional int32 numa_node_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_numa_node_id(), target);
  }

  // repeated string extra_info = 6;
  for (int i = 0, n = this->_internal_extra_info_size(); i < n; i++) {
    const auto& s = this->_internal_extra_info(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.DeviceOption.extra_info");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.DeviceOption)
  return target;
}

size_t DeviceOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.DeviceOption)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string extra_info = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(extra_info_.size());
  for (int i = 0, n = extra_info_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      extra_info_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string node_name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_node_name());
    }

    // optional int32 device_type = 1 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_device_type());
    }

    // optional int32 device_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_device_id());
    }

    // optional uint32 random_seed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_random_seed());
    }

    // optional int32 numa_node_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_numa_node_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeviceOption::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.DeviceOption)
  GOOGLE_DCHECK_NE(&from, this);
  const DeviceOption* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DeviceOption>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.DeviceOption)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.DeviceOption)
    MergeFrom(*source);
  }
}

void DeviceOption::MergeFrom(const DeviceOption& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.DeviceOption)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  extra_info_.MergeFrom(from.extra_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_node_name(from._internal_node_name());
    }
    if (cached_has_bits & 0x00000002u) {
      device_type_ = from.device_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      device_id_ = from.device_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      random_seed_ = from.random_seed_;
    }
    if (cached_has_bits & 0x00000010u) {
      numa_node_id_ = from.numa_node_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DeviceOption::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.DeviceOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeviceOption::CopyFrom(const DeviceOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.DeviceOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceOption::IsInitialized() const {
  return true;
}

void DeviceOption::InternalSwap(DeviceOption* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  extra_info_.InternalSwap(&other->extra_info_);
  node_name_.Swap(&other->node_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceOption, numa_node_id_)
      + sizeof(DeviceOption::numa_node_id_)
      - PROTOBUF_FIELD_OFFSET(DeviceOption, device_type_)>(
          reinterpret_cast<char*>(&device_type_),
          reinterpret_cast<char*>(&other->device_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeviceOption::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void OperatorDef::InitAsDefaultInstance() {
  ::caffe2::_OperatorDef_default_instance_._instance.get_mutable()->device_option_ = const_cast< ::caffe2::DeviceOption*>(
      ::caffe2::DeviceOption::internal_default_instance());
}
class OperatorDef::_Internal {
 public:
  using HasBits = decltype(std::declval<OperatorDef>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::caffe2::DeviceOption& device_option(const OperatorDef* msg);
  static void set_has_device_option(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_engine(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_gradient_op(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_op_version(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::caffe2::DeviceOption&
OperatorDef::_Internal::device_option(const OperatorDef* msg) {
  return *msg->device_option_;
}
OperatorDef::OperatorDef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  input_(arena),
  output_(arena),
  arg_(arena),
  control_input_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.OperatorDef)
}
OperatorDef::OperatorDef(const OperatorDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      input_(from.input_),
      output_(from.output_),
      arg_(from.arg_),
      control_input_(from.control_input_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  engine_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_engine()) {
    engine_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_engine(),
      GetArena());
  }
  debug_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_debug_info()) {
    debug_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_debug_info(),
      GetArena());
  }
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_domain()) {
    domain_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_domain(),
      GetArena());
  }
  if (from._internal_has_device_option()) {
    device_option_ = new ::caffe2::DeviceOption(*from.device_option_);
  } else {
    device_option_ = nullptr;
  }
  ::memcpy(&op_version_, &from.op_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_gradient_op_) -
    reinterpret_cast<char*>(&op_version_)) + sizeof(is_gradient_op_));
  // @@protoc_insertion_point(copy_constructor:caffe2.OperatorDef)
}

void OperatorDef::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  engine_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  debug_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  domain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&device_option_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_gradient_op_) -
      reinterpret_cast<char*>(&device_option_)) + sizeof(is_gradient_op_));
}

OperatorDef::~OperatorDef() {
  // @@protoc_insertion_point(destructor:caffe2.OperatorDef)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void OperatorDef::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  engine_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  debug_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  domain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete device_option_;
}

void OperatorDef::ArenaDtor(void* object) {
  OperatorDef* _this = reinterpret_cast< OperatorDef* >(object);
  (void)_this;
}
void OperatorDef::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OperatorDef::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OperatorDef& OperatorDef::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void OperatorDef::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.OperatorDef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  output_.Clear();
  arg_.Clear();
  control_input_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      engine_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      debug_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      domain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(device_option_ != nullptr);
      device_option_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&op_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_gradient_op_) -
        reinterpret_cast<char*>(&op_version_)) + sizeof(is_gradient_op_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperatorDef::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string input = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_input();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.input");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string output = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_output();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.output");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.Argument arg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arg(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .caffe2.DeviceOption device_option = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_option(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string engine = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_engine();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.engine");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string control_input = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_control_input();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.control_input");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool is_gradient_op = 9 [default = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_gradient_op(&has_bits);
          is_gradient_op_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string debug_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_debug_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.debug_info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string domain = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_domain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.OperatorDef.domain");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 op_version = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_op_version(&has_bits);
          op_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OperatorDef::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.OperatorDef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string input = 1;
  for (int i = 0, n = this->_internal_input_size(); i < n; i++) {
    const auto& s = this->_internal_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.input");
    target = stream->WriteString(1, s, target);
  }

  // repeated string output = 2;
  for (int i = 0, n = this->_internal_output_size(); i < n; i++) {
    const auto& s = this->_internal_output(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.output");
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string type = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_type(), target);
  }

  // repeated .caffe2.Argument arg = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_arg_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_arg(i), target, stream);
  }

  // optional .caffe2.DeviceOption device_option = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::device_option(this), target, stream);
  }

  // optional string engine = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_engine().data(), static_cast<int>(this->_internal_engine().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.engine");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_engine(), target);
  }

  // repeated string control_input = 8;
  for (int i = 0, n = this->_internal_control_input_size(); i < n; i++) {
    const auto& s = this->_internal_control_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.control_input");
    target = stream->WriteString(8, s, target);
  }

  // optional bool is_gradient_op = 9 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_gradient_op(), target);
  }

  // optional string debug_info = 10;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_debug_info().data(), static_cast<int>(this->_internal_debug_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.debug_info");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_debug_info(), target);
  }

  // optional string domain = 11;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_domain().data(), static_cast<int>(this->_internal_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.OperatorDef.domain");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_domain(), target);
  }

  // optional int64 op_version = 12;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_op_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.OperatorDef)
  return target;
}

size_t OperatorDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.OperatorDef)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string input = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(input_.size());
  for (int i = 0, n = input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      input_.Get(i));
  }

  // repeated string output = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(output_.size());
  for (int i = 0, n = output_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      output_.Get(i));
  }

  // repeated .caffe2.Argument arg = 5;
  total_size += 1UL * this->_internal_arg_size();
  for (const auto& msg : this->arg_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string control_input = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(control_input_.size());
  for (int i = 0, n = control_input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      control_input_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string engine = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_engine());
    }

    // optional string debug_info = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_debug_info());
    }

    // optional string domain = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_domain());
    }

    // optional .caffe2.DeviceOption device_option = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_option_);
    }

    // optional int64 op_version = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_op_version());
    }

    // optional bool is_gradient_op = 9 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OperatorDef::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.OperatorDef)
  GOOGLE_DCHECK_NE(&from, this);
  const OperatorDef* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<OperatorDef>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.OperatorDef)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.OperatorDef)
    MergeFrom(*source);
  }
}

void OperatorDef::MergeFrom(const OperatorDef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.OperatorDef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  arg_.MergeFrom(from.arg_);
  control_input_.MergeFrom(from.control_input_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_engine(from._internal_engine());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_debug_info(from._internal_debug_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_domain(from._internal_domain());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_device_option()->::caffe2::DeviceOption::MergeFrom(from._internal_device_option());
    }
    if (cached_has_bits & 0x00000040u) {
      op_version_ = from.op_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_gradient_op_ = from.is_gradient_op_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void OperatorDef::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.OperatorDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OperatorDef::CopyFrom(const OperatorDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.OperatorDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperatorDef::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(arg_)) return false;
  return true;
}

void OperatorDef::InternalSwap(OperatorDef* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  arg_.InternalSwap(&other->arg_);
  control_input_.InternalSwap(&other->control_input_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  engine_.Swap(&other->engine_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  debug_info_.Swap(&other->debug_info_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  domain_.Swap(&other->domain_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperatorDef, is_gradient_op_)
      + sizeof(OperatorDef::is_gradient_op_)
      - PROTOBUF_FIELD_OFFSET(OperatorDef, device_option_)>(
          reinterpret_cast<char*>(&device_option_),
          reinterpret_cast<char*>(&other->device_option_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperatorDef::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MapFieldEntry::InitAsDefaultInstance() {
}
class MapFieldEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<MapFieldEntry>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

MapFieldEntry::MapFieldEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.MapFieldEntry)
}
MapFieldEntry::MapFieldEntry(const MapFieldEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_key(),
      GetArena());
  }
  val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_val()) {
    val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_val(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:caffe2.MapFieldEntry)
}

void MapFieldEntry::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

MapFieldEntry::~MapFieldEntry() {
  // @@protoc_insertion_point(destructor:caffe2.MapFieldEntry)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MapFieldEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  val_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void MapFieldEntry::ArenaDtor(void* object) {
  MapFieldEntry* _this = reinterpret_cast< MapFieldEntry* >(object);
  (void)_this;
}
void MapFieldEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MapFieldEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MapFieldEntry& MapFieldEntry::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MapFieldEntry_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void MapFieldEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.MapFieldEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      val_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MapFieldEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.MapFieldEntry.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_val();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.MapFieldEntry.val");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MapFieldEntry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.MapFieldEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.MapFieldEntry.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required string val = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_val().data(), static_cast<int>(this->_internal_val().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.MapFieldEntry.val");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.MapFieldEntry)
  return target;
}

size_t MapFieldEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:caffe2.MapFieldEntry)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  if (_internal_has_val()) {
    // required string val = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_val());
  }

  return total_size;
}
size_t MapFieldEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.MapFieldEntry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());

    // required string val = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_val());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapFieldEntry::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.MapFieldEntry)
  GOOGLE_DCHECK_NE(&from, this);
  const MapFieldEntry* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MapFieldEntry>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.MapFieldEntry)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.MapFieldEntry)
    MergeFrom(*source);
  }
}

void MapFieldEntry::MergeFrom(const MapFieldEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.MapFieldEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_val(from._internal_val());
    }
  }
}

void MapFieldEntry::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.MapFieldEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapFieldEntry::CopyFrom(const MapFieldEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.MapFieldEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapFieldEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void MapFieldEntry::InternalSwap(MapFieldEntry* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  val_.Swap(&other->val_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata MapFieldEntry::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BackendOptions::InitAsDefaultInstance() {
}
class BackendOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<BackendOptions>()._has_bits_);
  static void set_has_backend_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

BackendOptions::BackendOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  option_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.BackendOptions)
}
BackendOptions::BackendOptions(const BackendOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      option_(from.option_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  backend_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_backend_name()) {
    backend_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_backend_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:caffe2.BackendOptions)
}

void BackendOptions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto.base);
  backend_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

BackendOptions::~BackendOptions() {
  // @@protoc_insertion_point(destructor:caffe2.BackendOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BackendOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  backend_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BackendOptions::ArenaDtor(void* object) {
  BackendOptions* _this = reinterpret_cast< BackendOptions* >(object);
  (void)_this;
}
void BackendOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BackendOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BackendOptions& BackendOptions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BackendOptions_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void BackendOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.BackendOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  option_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    backend_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BackendOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string backend_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_backend_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.BackendOptions.backend_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.MapFieldEntry option = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_option(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BackendOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.BackendOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string backend_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_backend_name().data(), static_cast<int>(this->_internal_backend_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.BackendOptions.backend_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_backend_name(), target);
  }

  // repeated .caffe2.MapFieldEntry option = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_option_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_option(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.BackendOptions)
  return target;
}

size_t BackendOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.BackendOptions)
  size_t total_size = 0;

  // required string backend_name = 1;
  if (_internal_has_backend_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_backend_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.MapFieldEntry option = 2;
  total_size += 1UL * this->_internal_option_size();
  for (const auto& msg : this->option_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BackendOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.BackendOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const BackendOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BackendOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.BackendOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.BackendOptions)
    MergeFrom(*source);
  }
}

void BackendOptions::MergeFrom(const BackendOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.BackendOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  option_.MergeFrom(from.option_);
  if (from._internal_has_backend_name()) {
    _internal_set_backend_name(from._internal_backend_name());
  }
}

void BackendOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.BackendOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BackendOptions::CopyFrom(const BackendOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.BackendOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BackendOptions::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(option_)) return false;
  return true;
}

void BackendOptions::InternalSwap(BackendOptions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  option_.InternalSwap(&other->option_);
  backend_name_.Swap(&other->backend_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata BackendOptions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PartitionInfo::InitAsDefaultInstance() {
}
class PartitionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionInfo>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_extra_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

PartitionInfo::PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  device_id_(arena),
  backend_options_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.PartitionInfo)
}
PartitionInfo::PartitionInfo(const PartitionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      device_id_(from.device_id_),
      backend_options_(from.backend_options_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  extra_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_extra_info()) {
    extra_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_extra_info(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:caffe2.PartitionInfo)
}

void PartitionInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  extra_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

PartitionInfo::~PartitionInfo() {
  // @@protoc_insertion_point(destructor:caffe2.PartitionInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PartitionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  extra_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PartitionInfo::ArenaDtor(void* object) {
  PartitionInfo* _this = reinterpret_cast< PartitionInfo* >(object);
  (void)_this;
}
void PartitionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PartitionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PartitionInfo& PartitionInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PartitionInfo_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void PartitionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.PartitionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_id_.Clear();
  backend_options_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      extra_info_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.PartitionInfo.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated int32 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_device_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_device_id(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string extra_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_extra_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.PartitionInfo.extra_info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.BackendOptions backend_options = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_backend_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PartitionInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.PartitionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.PartitionInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated int32 device_id = 2;
  for (int i = 0, n = this->_internal_device_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_device_id(i), target);
  }

  // optional string extra_info = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_extra_info().data(), static_cast<int>(this->_internal_extra_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.PartitionInfo.extra_info");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_extra_info(), target);
  }

  // repeated .caffe2.BackendOptions backend_options = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_backend_options_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_backend_options(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.PartitionInfo)
  return target;
}

size_t PartitionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.PartitionInfo)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 device_id = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->device_id_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_device_id_size());
    total_size += data_size;
  }

  // repeated .caffe2.BackendOptions backend_options = 4;
  total_size += 1UL * this->_internal_backend_options_size();
  for (const auto& msg : this->backend_options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string extra_info = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_extra_info());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PartitionInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.PartitionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const PartitionInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PartitionInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.PartitionInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.PartitionInfo)
    MergeFrom(*source);
  }
}

void PartitionInfo::MergeFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.PartitionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  device_id_.MergeFrom(from.device_id_);
  backend_options_.MergeFrom(from.backend_options_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_extra_info(from._internal_extra_info());
    }
  }
}

void PartitionInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.PartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PartitionInfo::CopyFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.PartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(backend_options_)) return false;
  return true;
}

void PartitionInfo::InternalSwap(PartitionInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  device_id_.InternalSwap(&other->device_id_);
  backend_options_.InternalSwap(&other->backend_options_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  extra_info_.Swap(&other->extra_info_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void NetDef::InitAsDefaultInstance() {
  ::caffe2::_NetDef_default_instance_._instance.get_mutable()->device_option_ = const_cast< ::caffe2::DeviceOption*>(
      ::caffe2::DeviceOption::internal_default_instance());
}
class NetDef::_Internal {
 public:
  using HasBits = decltype(std::declval<NetDef>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_workers(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::caffe2::DeviceOption& device_option(const NetDef* msg);
  static void set_has_device_option(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::caffe2::DeviceOption&
NetDef::_Internal::device_option(const NetDef* msg) {
  return *msg->device_option_;
}
NetDef::NetDef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  op_(arena),
  arg_(arena),
  external_input_(arena),
  external_output_(arena),
  partition_info_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.NetDef)
}
NetDef::NetDef(const NetDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      op_(from.op_),
      arg_(from.arg_),
      external_input_(from.external_input_),
      external_output_(from.external_output_),
      partition_info_(from.partition_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  if (from._internal_has_device_option()) {
    device_option_ = new ::caffe2::DeviceOption(*from.device_option_);
  } else {
    device_option_ = nullptr;
  }
  num_workers_ = from.num_workers_;
  // @@protoc_insertion_point(copy_constructor:caffe2.NetDef)
}

void NetDef::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&device_option_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_workers_) -
      reinterpret_cast<char*>(&device_option_)) + sizeof(num_workers_));
}

NetDef::~NetDef() {
  // @@protoc_insertion_point(destructor:caffe2.NetDef)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void NetDef::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete device_option_;
}

void NetDef::ArenaDtor(void* object) {
  NetDef* _this = reinterpret_cast< NetDef* >(object);
  (void)_this;
}
void NetDef::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NetDef::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NetDef& NetDef::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Argument_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void NetDef::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.NetDef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  op_.Clear();
  arg_.Clear();
  external_input_.Clear();
  external_output_.Clear();
  partition_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(device_option_ != nullptr);
      device_option_->Clear();
    }
  }
  num_workers_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetDef::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.NetDef.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.OperatorDef op = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_op(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.NetDef.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_workers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_num_workers(&has_bits);
          num_workers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.DeviceOption device_option = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_option(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.Argument arg = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arg(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string external_input = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_external_input();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.NetDef.external_input");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string external_output = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_external_output();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.NetDef.external_output");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.PartitionInfo partition_info = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partition_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NetDef::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.NetDef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.NetDef.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .caffe2.OperatorDef op = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_op_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_op(i), target, stream);
  }

  // optional string type = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.NetDef.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // optional int32 num_workers = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_num_workers(), target);
  }

  // optional .caffe2.DeviceOption device_option = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::device_option(this), target, stream);
  }

  // repeated .caffe2.Argument arg = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_arg_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_arg(i), target, stream);
  }

  // repeated string external_input = 7;
  for (int i = 0, n = this->_internal_external_input_size(); i < n; i++) {
    const auto& s = this->_internal_external_input(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.NetDef.external_input");
    target = stream->WriteString(7, s, target);
  }

  // repeated string external_output = 8;
  for (int i = 0, n = this->_internal_external_output_size(); i < n; i++) {
    const auto& s = this->_internal_external_output(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.NetDef.external_output");
    target = stream->WriteString(8, s, target);
  }

  // repeated .caffe2.PartitionInfo partition_info = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_partition_info_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_partition_info(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.NetDef)
  return target;
}

size_t NetDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.NetDef)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.OperatorDef op = 2;
  total_size += 1UL * this->_internal_op_size();
  for (const auto& msg : this->op_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .caffe2.Argument arg = 6;
  total_size += 1UL * this->_internal_arg_size();
  for (const auto& msg : this->arg_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string external_input = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(external_input_.size());
  for (int i = 0, n = external_input_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      external_input_.Get(i));
  }

  // repeated string external_output = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(external_output_.size());
  for (int i = 0, n = external_output_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      external_output_.Get(i));
  }

  // repeated .caffe2.PartitionInfo partition_info = 9;
  total_size += 1UL * this->_internal_partition_info_size();
  for (const auto& msg : this->partition_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional .caffe2.DeviceOption device_option = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_option_);
    }

    // optional int32 num_workers = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_workers());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NetDef::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.NetDef)
  GOOGLE_DCHECK_NE(&from, this);
  const NetDef* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NetDef>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.NetDef)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.NetDef)
    MergeFrom(*source);
  }
}

void NetDef::MergeFrom(const NetDef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.NetDef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  op_.MergeFrom(from.op_);
  arg_.MergeFrom(from.arg_);
  external_input_.MergeFrom(from.external_input_);
  external_output_.MergeFrom(from.external_output_);
  partition_info_.MergeFrom(from.partition_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_device_option()->::caffe2::DeviceOption::MergeFrom(from._internal_device_option());
    }
    if (cached_has_bits & 0x00000008u) {
      num_workers_ = from.num_workers_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NetDef::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.NetDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetDef::CopyFrom(const NetDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.NetDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetDef::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(op_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(arg_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(partition_info_)) return false;
  return true;
}

void NetDef::InternalSwap(NetDef* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  op_.InternalSwap(&other->op_);
  arg_.InternalSwap(&other->arg_);
  external_input_.InternalSwap(&other->external_input_);
  external_output_.InternalSwap(&other->external_output_);
  partition_info_.InternalSwap(&other->partition_info_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetDef, num_workers_)
      + sizeof(NetDef::num_workers_)
      - PROTOBUF_FIELD_OFFSET(NetDef, device_option_)>(
          reinterpret_cast<char*>(&device_option_),
          reinterpret_cast<char*>(&other->device_option_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NetDef::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ExecutionStep::InitAsDefaultInstance() {
}
class ExecutionStep::_Internal {
 public:
  using HasBits = decltype(std::declval<ExecutionStep>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_iter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_criteria_network(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_report_net(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_report_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_run_every_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_concurrent_substeps(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_should_stop_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_only_once(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_create_workspace(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_num_concurrent_instances(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

ExecutionStep::ExecutionStep(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  substep_(arena),
  network_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.ExecutionStep)
}
ExecutionStep::ExecutionStep(const ExecutionStep& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      substep_(from.substep_),
      network_(from.network_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  criteria_network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_criteria_network()) {
    criteria_network_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_criteria_network(),
      GetArena());
  }
  report_net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_report_net()) {
    report_net_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_report_net(),
      GetArena());
  }
  should_stop_blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_should_stop_blob()) {
    should_stop_blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_should_stop_blob(),
      GetArena());
  }
  ::memcpy(&num_iter_, &from.num_iter_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_concurrent_instances_) -
    reinterpret_cast<char*>(&num_iter_)) + sizeof(num_concurrent_instances_));
  // @@protoc_insertion_point(copy_constructor:caffe2.ExecutionStep)
}

void ExecutionStep::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  criteria_network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  report_net_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  should_stop_blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&num_iter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_concurrent_instances_) -
      reinterpret_cast<char*>(&num_iter_)) + sizeof(num_concurrent_instances_));
}

ExecutionStep::~ExecutionStep() {
  // @@protoc_insertion_point(destructor:caffe2.ExecutionStep)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ExecutionStep::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  criteria_network_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  report_net_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  should_stop_blob_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ExecutionStep::ArenaDtor(void* object) {
  ExecutionStep* _this = reinterpret_cast< ExecutionStep* >(object);
  (void)_this;
}
void ExecutionStep::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExecutionStep::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ExecutionStep& ExecutionStep::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ExecutionStep_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void ExecutionStep::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.ExecutionStep)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  substep_.Clear();
  network_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      criteria_network_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      report_net_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      should_stop_blob_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&num_iter_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&only_once_) -
        reinterpret_cast<char*>(&num_iter_)) + sizeof(only_once_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&create_workspace_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_concurrent_instances_) -
        reinterpret_cast<char*>(&create_workspace_)) + sizeof(num_concurrent_instances_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExecutionStep::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.ExecutionStep.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.ExecutionStep substep = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_substep(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string network = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_network();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.ExecutionStep.network");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int64 num_iter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_num_iter(&has_bits);
          num_iter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string criteria_network = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_criteria_network();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.ExecutionStep.criteria_network");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool concurrent_substeps = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_concurrent_substeps(&has_bits);
          concurrent_substeps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string report_net = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_report_net();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.ExecutionStep.report_net");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 report_interval = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_report_interval(&has_bits);
          report_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string should_stop_blob = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_should_stop_blob();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.ExecutionStep.should_stop_blob");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool only_once = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_only_once(&has_bits);
          only_once_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 run_every_ms = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_run_every_ms(&has_bits);
          run_every_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool create_workspace = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_create_workspace(&has_bits);
          create_workspace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 num_concurrent_instances = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_num_concurrent_instances(&has_bits);
          num_concurrent_instances_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExecutionStep::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.ExecutionStep)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.ExecutionStep.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .caffe2.ExecutionStep substep = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_substep_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_substep(i), target, stream);
  }

  // repeated string network = 3;
  for (int i = 0, n = this->_internal_network_size(); i < n; i++) {
    const auto& s = this->_internal_network(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.ExecutionStep.network");
    target = stream->WriteString(3, s, target);
  }

  // optional int64 num_iter = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_num_iter(), target);
  }

  // optional string criteria_network = 5 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_criteria_network().data(), static_cast<int>(this->_internal_criteria_network().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.ExecutionStep.criteria_network");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_criteria_network(), target);
  }

  // optional bool concurrent_substeps = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_concurrent_substeps(), target);
  }

  // optional string report_net = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_report_net().data(), static_cast<int>(this->_internal_report_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.ExecutionStep.report_net");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_report_net(), target);
  }

  // optional int32 report_interval = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_report_interval(), target);
  }

  // optional string should_stop_blob = 9;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_should_stop_blob().data(), static_cast<int>(this->_internal_should_stop_blob().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.ExecutionStep.should_stop_blob");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_should_stop_blob(), target);
  }

  // optional bool only_once = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_only_once(), target);
  }

  // optional int64 run_every_ms = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(11, this->_internal_run_every_ms(), target);
  }

  // optional bool create_workspace = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_create_workspace(), target);
  }

  // optional int32 num_concurrent_instances = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_num_concurrent_instances(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.ExecutionStep)
  return target;
}

size_t ExecutionStep::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.ExecutionStep)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.ExecutionStep substep = 2;
  total_size += 1UL * this->_internal_substep_size();
  for (const auto& msg : this->substep_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string network = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(network_.size());
  for (int i = 0, n = network_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      network_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string criteria_network = 5 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_criteria_network());
    }

    // optional string report_net = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_report_net());
    }

    // optional string should_stop_blob = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_should_stop_blob());
    }

    // optional int64 num_iter = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_num_iter());
    }

    // optional int32 report_interval = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_report_interval());
    }

    // optional bool concurrent_substeps = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool only_once = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool create_workspace = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int64 run_every_ms = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_run_every_ms());
    }

    // optional int32 num_concurrent_instances = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_concurrent_instances());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExecutionStep::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.ExecutionStep)
  GOOGLE_DCHECK_NE(&from, this);
  const ExecutionStep* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExecutionStep>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.ExecutionStep)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.ExecutionStep)
    MergeFrom(*source);
  }
}

void ExecutionStep::MergeFrom(const ExecutionStep& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.ExecutionStep)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  substep_.MergeFrom(from.substep_);
  network_.MergeFrom(from.network_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_criteria_network(from._internal_criteria_network());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_report_net(from._internal_report_net());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_should_stop_blob(from._internal_should_stop_blob());
    }
    if (cached_has_bits & 0x00000010u) {
      num_iter_ = from.num_iter_;
    }
    if (cached_has_bits & 0x00000020u) {
      report_interval_ = from.report_interval_;
    }
    if (cached_has_bits & 0x00000040u) {
      concurrent_substeps_ = from.concurrent_substeps_;
    }
    if (cached_has_bits & 0x00000080u) {
      only_once_ = from.only_once_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      create_workspace_ = from.create_workspace_;
    }
    if (cached_has_bits & 0x00000200u) {
      run_every_ms_ = from.run_every_ms_;
    }
    if (cached_has_bits & 0x00000400u) {
      num_concurrent_instances_ = from.num_concurrent_instances_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ExecutionStep::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.ExecutionStep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutionStep::CopyFrom(const ExecutionStep& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.ExecutionStep)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutionStep::IsInitialized() const {
  return true;
}

void ExecutionStep::InternalSwap(ExecutionStep* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  substep_.InternalSwap(&other->substep_);
  network_.InternalSwap(&other->network_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  criteria_network_.Swap(&other->criteria_network_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  report_net_.Swap(&other->report_net_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  should_stop_blob_.Swap(&other->should_stop_blob_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExecutionStep, num_concurrent_instances_)
      + sizeof(ExecutionStep::num_concurrent_instances_)
      - PROTOBUF_FIELD_OFFSET(ExecutionStep, num_iter_)>(
          reinterpret_cast<char*>(&num_iter_),
          reinterpret_cast<char*>(&other->num_iter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExecutionStep::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PlanDef::InitAsDefaultInstance() {
}
class PlanDef::_Internal {
 public:
  using HasBits = decltype(std::declval<PlanDef>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlanDef::PlanDef(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  network_(arena),
  execution_step_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.PlanDef)
}
PlanDef::PlanDef(const PlanDef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      network_(from.network_),
      execution_step_(from.execution_step_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:caffe2.PlanDef)
}

void PlanDef::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PlanDef_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

PlanDef::~PlanDef() {
  // @@protoc_insertion_point(destructor:caffe2.PlanDef)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PlanDef::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PlanDef::ArenaDtor(void* object) {
  PlanDef* _this = reinterpret_cast< PlanDef* >(object);
  (void)_this;
}
void PlanDef::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlanDef::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PlanDef& PlanDef::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PlanDef_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void PlanDef::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.PlanDef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  network_.Clear();
  execution_step_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanDef::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.PlanDef.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.NetDef network = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_network(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .caffe2.ExecutionStep execution_step = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_execution_step(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PlanDef::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.PlanDef)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.PlanDef.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .caffe2.NetDef network = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_network_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_network(i), target, stream);
  }

  // repeated .caffe2.ExecutionStep execution_step = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_execution_step_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_execution_step(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.PlanDef)
  return target;
}

size_t PlanDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.PlanDef)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.NetDef network = 2;
  total_size += 1UL * this->_internal_network_size();
  for (const auto& msg : this->network_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .caffe2.ExecutionStep execution_step = 3;
  total_size += 1UL * this->_internal_execution_step_size();
  for (const auto& msg : this->execution_step_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PlanDef::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.PlanDef)
  GOOGLE_DCHECK_NE(&from, this);
  const PlanDef* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PlanDef>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.PlanDef)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.PlanDef)
    MergeFrom(*source);
  }
}

void PlanDef::MergeFrom(const PlanDef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.PlanDef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  network_.MergeFrom(from.network_);
  execution_step_.MergeFrom(from.execution_step_);
  if (from._internal_has_name()) {
    _internal_set_name(from._internal_name());
  }
}

void PlanDef::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.PlanDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlanDef::CopyFrom(const PlanDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.PlanDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanDef::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(network_)) return false;
  return true;
}

void PlanDef::InternalSwap(PlanDef* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  network_.InternalSwap(&other->network_);
  execution_step_.InternalSwap(&other->execution_step_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanDef::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BlobProto::InitAsDefaultInstance() {
  ::caffe2::_BlobProto_default_instance_._instance.get_mutable()->tensor_ = const_cast< ::caffe2::TensorProto*>(
      ::caffe2::TensorProto::internal_default_instance());
  ::caffe2::_BlobProto_default_instance_._instance.get_mutable()->qtensor_ = const_cast< ::caffe2::QTensorProto*>(
      ::caffe2::QTensorProto::internal_default_instance());
}
class BlobProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BlobProto>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::caffe2::TensorProto& tensor(const BlobProto* msg);
  static void set_has_tensor(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::caffe2::QTensorProto& qtensor(const BlobProto* msg);
  static void set_has_qtensor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_content_num_chunks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_content_chunk_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::caffe2::TensorProto&
BlobProto::_Internal::tensor(const BlobProto* msg) {
  return *msg->tensor_;
}
const ::caffe2::QTensorProto&
BlobProto::_Internal::qtensor(const BlobProto* msg) {
  return *msg->qtensor_;
}
BlobProto::BlobProto(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.BlobProto)
}
BlobProto::BlobProto(const BlobProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_content()) {
    content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_content(),
      GetArena());
  }
  if (from._internal_has_tensor()) {
    tensor_ = new ::caffe2::TensorProto(*from.tensor_);
  } else {
    tensor_ = nullptr;
  }
  if (from._internal_has_qtensor()) {
    qtensor_ = new ::caffe2::QTensorProto(*from.qtensor_);
  } else {
    qtensor_ = nullptr;
  }
  ::memcpy(&content_num_chunks_, &from.content_num_chunks_,
    static_cast<size_t>(reinterpret_cast<char*>(&content_chunk_id_) -
    reinterpret_cast<char*>(&content_num_chunks_)) + sizeof(content_chunk_id_));
  // @@protoc_insertion_point(copy_constructor:caffe2.BlobProto)
}

void BlobProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BlobProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&tensor_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&content_chunk_id_) -
      reinterpret_cast<char*>(&tensor_)) + sizeof(content_chunk_id_));
}

BlobProto::~BlobProto() {
  // @@protoc_insertion_point(destructor:caffe2.BlobProto)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BlobProto::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  content_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete tensor_;
  if (this != internal_default_instance()) delete qtensor_;
}

void BlobProto::ArenaDtor(void* object) {
  BlobProto* _this = reinterpret_cast< BlobProto* >(object);
  (void)_this;
}
void BlobProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BlobProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BlobProto& BlobProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BlobProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void BlobProto::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.BlobProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      content_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(tensor_ != nullptr);
      tensor_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(qtensor_ != nullptr);
      qtensor_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&content_num_chunks_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&content_chunk_id_) -
        reinterpret_cast<char*>(&content_num_chunks_)) + sizeof(content_chunk_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlobProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.BlobProto.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.BlobProto.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.TensorProto tensor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tensor(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes content = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_content();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.QTensorProto qtensor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_qtensor(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 content_num_chunks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_content_num_chunks(&has_bits);
          content_num_chunks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 content_chunk_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_content_chunk_id(&has_bits);
          content_chunk_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BlobProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.BlobProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.BlobProto.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.BlobProto.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // optional .caffe2.TensorProto tensor = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::tensor(this), target, stream);
  }

  // optional bytes content = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_content(), target);
  }

  // optional .caffe2.QTensorProto qtensor = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::qtensor(this), target, stream);
  }

  // optional int32 content_num_chunks = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_content_num_chunks(), target);
  }

  // optional int32 content_chunk_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_content_chunk_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.BlobProto)
  return target;
}

size_t BlobProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.BlobProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional bytes content = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_content());
    }

    // optional .caffe2.TensorProto tensor = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tensor_);
    }

    // optional .caffe2.QTensorProto qtensor = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *qtensor_);
    }

    // optional int32 content_num_chunks = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_content_num_chunks());
    }

    // optional int32 content_chunk_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_content_chunk_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlobProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.BlobProto)
  GOOGLE_DCHECK_NE(&from, this);
  const BlobProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BlobProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.BlobProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.BlobProto)
    MergeFrom(*source);
  }
}

void BlobProto::MergeFrom(const BlobProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.BlobProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_content(from._internal_content());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_tensor()->::caffe2::TensorProto::MergeFrom(from._internal_tensor());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_qtensor()->::caffe2::QTensorProto::MergeFrom(from._internal_qtensor());
    }
    if (cached_has_bits & 0x00000020u) {
      content_num_chunks_ = from.content_num_chunks_;
    }
    if (cached_has_bits & 0x00000040u) {
      content_chunk_id_ = from.content_chunk_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BlobProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.BlobProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobProto::CopyFrom(const BlobProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.BlobProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobProto::IsInitialized() const {
  if (_internal_has_tensor()) {
    if (!tensor_->IsInitialized()) return false;
  }
  if (_internal_has_qtensor()) {
    if (!qtensor_->IsInitialized()) return false;
  }
  return true;
}

void BlobProto::InternalSwap(BlobProto* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  content_.Swap(&other->content_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BlobProto, content_chunk_id_)
      + sizeof(BlobProto::content_chunk_id_)
      - PROTOBUF_FIELD_OFFSET(BlobProto, tensor_)>(
          reinterpret_cast<char*>(&tensor_),
          reinterpret_cast<char*>(&other->tensor_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BlobProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void DBReaderProto::InitAsDefaultInstance() {
}
class DBReaderProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DBReaderProto>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_db_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DBReaderProto::DBReaderProto(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.DBReaderProto)
}
DBReaderProto::DBReaderProto(const DBReaderProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_source()) {
    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_source(),
      GetArena());
  }
  db_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_db_type()) {
    db_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_db_type(),
      GetArena());
  }
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_key(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:caffe2.DBReaderProto)
}

void DBReaderProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DBReaderProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  db_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

DBReaderProto::~DBReaderProto() {
  // @@protoc_insertion_point(destructor:caffe2.DBReaderProto)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void DBReaderProto::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  source_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  db_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DBReaderProto::ArenaDtor(void* object) {
  DBReaderProto* _this = reinterpret_cast< DBReaderProto* >(object);
  (void)_this;
}
void DBReaderProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DBReaderProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DBReaderProto& DBReaderProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DBReaderProto_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void DBReaderProto::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.DBReaderProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      db_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      key_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DBReaderProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.DBReaderProto.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_source();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.DBReaderProto.source");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string db_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_db_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.DBReaderProto.db_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.DBReaderProto.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DBReaderProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.DBReaderProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.DBReaderProto.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string source = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_source().data(), static_cast<int>(this->_internal_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.DBReaderProto.source");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_source(), target);
  }

  // optional string db_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_db_type().data(), static_cast<int>(this->_internal_db_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.DBReaderProto.db_type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_db_type(), target);
  }

  // optional string key = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.DBReaderProto.key");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.DBReaderProto)
  return target;
}

size_t DBReaderProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.DBReaderProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string source = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_source());
    }

    // optional string db_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_db_type());
    }

    // optional string key = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DBReaderProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.DBReaderProto)
  GOOGLE_DCHECK_NE(&from, this);
  const DBReaderProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DBReaderProto>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.DBReaderProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.DBReaderProto)
    MergeFrom(*source);
  }
}

void DBReaderProto::MergeFrom(const DBReaderProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.DBReaderProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_source(from._internal_source());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_db_type(from._internal_db_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_key(from._internal_key());
    }
  }
}

void DBReaderProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.DBReaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DBReaderProto::CopyFrom(const DBReaderProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.DBReaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DBReaderProto::IsInitialized() const {
  return true;
}

void DBReaderProto::InternalSwap(DBReaderProto* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  source_.Swap(&other->source_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  db_type_.Swap(&other->db_type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata DBReaderProto::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BlobSerializationOptions::InitAsDefaultInstance() {
}
class BlobSerializationOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<BlobSerializationOptions>()._has_bits_);
  static void set_has_blob_name_regex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chunk_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_float_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BlobSerializationOptions::BlobSerializationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.BlobSerializationOptions)
}
BlobSerializationOptions::BlobSerializationOptions(const BlobSerializationOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  blob_name_regex_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blob_name_regex()) {
    blob_name_regex_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_blob_name_regex(),
      GetArena());
  }
  ::memcpy(&chunk_size_, &from.chunk_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&float_format_) -
    reinterpret_cast<char*>(&chunk_size_)) + sizeof(float_format_));
  // @@protoc_insertion_point(copy_constructor:caffe2.BlobSerializationOptions)
}

void BlobSerializationOptions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base);
  blob_name_regex_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&chunk_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&float_format_) -
      reinterpret_cast<char*>(&chunk_size_)) + sizeof(float_format_));
}

BlobSerializationOptions::~BlobSerializationOptions() {
  // @@protoc_insertion_point(destructor:caffe2.BlobSerializationOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BlobSerializationOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  blob_name_regex_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BlobSerializationOptions::ArenaDtor(void* object) {
  BlobSerializationOptions* _this = reinterpret_cast< BlobSerializationOptions* >(object);
  (void)_this;
}
void BlobSerializationOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BlobSerializationOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BlobSerializationOptions& BlobSerializationOptions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BlobSerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void BlobSerializationOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.BlobSerializationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    blob_name_regex_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&chunk_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&float_format_) -
        reinterpret_cast<char*>(&chunk_size_)) + sizeof(float_format_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlobSerializationOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string blob_name_regex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_blob_name_regex();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "caffe2.BlobSerializationOptions.blob_name_regex");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 chunk_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_chunk_size(&has_bits);
          chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .caffe2.BlobSerializationOptions.FloatFormat float_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::caffe2::BlobSerializationOptions_FloatFormat_IsValid(val))) {
            _internal_set_float_format(static_cast<::caffe2::BlobSerializationOptions_FloatFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BlobSerializationOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.BlobSerializationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string blob_name_regex = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_blob_name_regex().data(), static_cast<int>(this->_internal_blob_name_regex().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "caffe2.BlobSerializationOptions.blob_name_regex");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_blob_name_regex(), target);
  }

  // optional int64 chunk_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_chunk_size(), target);
  }

  // optional .caffe2.BlobSerializationOptions.FloatFormat float_format = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_float_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.BlobSerializationOptions)
  return target;
}

size_t BlobSerializationOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.BlobSerializationOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string blob_name_regex = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_blob_name_regex());
    }

    // optional int64 chunk_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_chunk_size());
    }

    // optional .caffe2.BlobSerializationOptions.FloatFormat float_format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_float_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlobSerializationOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.BlobSerializationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const BlobSerializationOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BlobSerializationOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.BlobSerializationOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.BlobSerializationOptions)
    MergeFrom(*source);
  }
}

void BlobSerializationOptions::MergeFrom(const BlobSerializationOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.BlobSerializationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_blob_name_regex(from._internal_blob_name_regex());
    }
    if (cached_has_bits & 0x00000002u) {
      chunk_size_ = from.chunk_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      float_format_ = from.float_format_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BlobSerializationOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.BlobSerializationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlobSerializationOptions::CopyFrom(const BlobSerializationOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.BlobSerializationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlobSerializationOptions::IsInitialized() const {
  return true;
}

void BlobSerializationOptions::InternalSwap(BlobSerializationOptions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  blob_name_regex_.Swap(&other->blob_name_regex_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BlobSerializationOptions, float_format_)
      + sizeof(BlobSerializationOptions::float_format_)
      - PROTOBUF_FIELD_OFFSET(BlobSerializationOptions, chunk_size_)>(
          reinterpret_cast<char*>(&chunk_size_),
          reinterpret_cast<char*>(&other->chunk_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BlobSerializationOptions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SerializationOptions::InitAsDefaultInstance() {
}
class SerializationOptions::_Internal {
 public:
};

SerializationOptions::SerializationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  options_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:caffe2.SerializationOptions)
}
SerializationOptions::SerializationOptions(const SerializationOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      options_(from.options_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:caffe2.SerializationOptions)
}

void SerializationOptions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base);
}

SerializationOptions::~SerializationOptions() {
  // @@protoc_insertion_point(destructor:caffe2.SerializationOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SerializationOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SerializationOptions::ArenaDtor(void* object) {
  SerializationOptions* _this = reinterpret_cast< SerializationOptions* >(object);
  (void)_this;
}
void SerializationOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SerializationOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SerializationOptions& SerializationOptions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SerializationOptions_caffe2_2fproto_2fcaffe2_2eproto.base);
  return *internal_default_instance();
}


void SerializationOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:caffe2.SerializationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  options_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SerializationOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .caffe2.BlobSerializationOptions options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SerializationOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:caffe2.SerializationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .caffe2.BlobSerializationOptions options = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_options_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_options(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:caffe2.SerializationOptions)
  return target;
}

size_t SerializationOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:caffe2.SerializationOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .caffe2.BlobSerializationOptions options = 1;
  total_size += 1UL * this->_internal_options_size();
  for (const auto& msg : this->options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SerializationOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:caffe2.SerializationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const SerializationOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SerializationOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:caffe2.SerializationOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:caffe2.SerializationOptions)
    MergeFrom(*source);
  }
}

void SerializationOptions::MergeFrom(const SerializationOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:caffe2.SerializationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  options_.MergeFrom(from.options_);
}

void SerializationOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:caffe2.SerializationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerializationOptions::CopyFrom(const SerializationOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:caffe2.SerializationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerializationOptions::IsInitialized() const {
  return true;
}

void SerializationOptions::InternalSwap(SerializationOptions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  options_.InternalSwap(&other->options_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SerializationOptions::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace caffe2
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::caffe2::TensorProto_Segment* Arena::CreateMaybeMessage< ::caffe2::TensorProto_Segment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorProto_Segment >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::TensorProto* Arena::CreateMaybeMessage< ::caffe2::TensorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::QTensorProto* Arena::CreateMaybeMessage< ::caffe2::QTensorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::QTensorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::TensorProtos* Arena::CreateMaybeMessage< ::caffe2::TensorProtos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorProtos >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::TensorShape* Arena::CreateMaybeMessage< ::caffe2::TensorShape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorShape >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::TensorShapes* Arena::CreateMaybeMessage< ::caffe2::TensorShapes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorShapes >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::TensorBoundShape* Arena::CreateMaybeMessage< ::caffe2::TensorBoundShape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorBoundShape >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::TensorBoundShapes* Arena::CreateMaybeMessage< ::caffe2::TensorBoundShapes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::TensorBoundShapes >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::AOTConfig* Arena::CreateMaybeMessage< ::caffe2::AOTConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::AOTConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::Argument* Arena::CreateMaybeMessage< ::caffe2::Argument >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::Argument >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::DeviceOption* Arena::CreateMaybeMessage< ::caffe2::DeviceOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::DeviceOption >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::OperatorDef* Arena::CreateMaybeMessage< ::caffe2::OperatorDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::OperatorDef >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::MapFieldEntry* Arena::CreateMaybeMessage< ::caffe2::MapFieldEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::MapFieldEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::BackendOptions* Arena::CreateMaybeMessage< ::caffe2::BackendOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::BackendOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::PartitionInfo* Arena::CreateMaybeMessage< ::caffe2::PartitionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::PartitionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::NetDef* Arena::CreateMaybeMessage< ::caffe2::NetDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::NetDef >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::ExecutionStep* Arena::CreateMaybeMessage< ::caffe2::ExecutionStep >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::ExecutionStep >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::PlanDef* Arena::CreateMaybeMessage< ::caffe2::PlanDef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::PlanDef >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::BlobProto* Arena::CreateMaybeMessage< ::caffe2::BlobProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::BlobProto >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::DBReaderProto* Arena::CreateMaybeMessage< ::caffe2::DBReaderProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::DBReaderProto >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::BlobSerializationOptions* Arena::CreateMaybeMessage< ::caffe2::BlobSerializationOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::BlobSerializationOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::caffe2::SerializationOptions* Arena::CreateMaybeMessage< ::caffe2::SerializationOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::caffe2::SerializationOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
