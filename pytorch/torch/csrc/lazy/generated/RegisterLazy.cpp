// required for old g++ to compile PRId64 macros, see
// https://github.com/pytorch/pytorch/issues/3571
// for context
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

// an external backend might generate file within its code tree
// and check all the source files within the tree with clang-format.
// so, disable it since the backend might have a different config.
// clang-format off

// NOTE: This condition is true for all PyTorch internal libraries, it
//       just excludes external projects such as torch_xla which
//       re-use some of the PyTorch codegen machinery.
#if defined(CAFFE2_BUILD_MAIN_LIB)        || \
    defined(TORCH_CUDA_BUILD_MAIN_LIB)    || \
    defined(TORCH_HIP_BUILD_MAIN_LIB)     || \
    defined(TORCH_CUDA_CU_BUILD_MAIN_LIB) || \
    defined(TORCH_CUDA_CPP_BUILD_MAIN_LIB)
#define TORCH_ASSERT_ONLY_METHOD_OPERATORS
#endif

// @generated by torchgen/gen.py from RegisterDispatchKey.cpp

#include <c10/core/TensorImpl.h>
#include <c10/core/Allocator.h>
#include <ATen/DeviceGuard.h>
#include <ATen/NamedTensorUtils.h>
#include <ATen/Utils.h>
#include <ATen/WrapDimUtils.h>
#include <ATen/Dispatch.h>
#include <c10/util/ExclusivelyOwned.h>
#include <c10/util/Half.h>
#include <c10/core/UndefinedTensorImpl.h>
#include <c10/util/Optional.h>
#include <ATen/Tensor.h>
#include <ATen/native/Resize.h>

#include <cstddef>
#include <functional>
#include <memory>
#include <utility>

#include <ATen/Config.h>
#include <ATen/core/op_registration/adaption.h>
#include <torch/library.h>

#include <torch/csrc/lazy/generated/LazyNativeFunctions.h>
#include <ATen/ops/as_strided_native.h>
#include <ATen/ops/empty.h>
#include <ATen/ops/empty_strided.h>
#include <ATen/ops/_copy_from_and_resize.h>
#include <ATen/ops/_copy_from.h>


// See template file RegisterDispatchDefinitions.ini
namespace at {
// NB: TORCH_LIBRARY_IMPL must be in an anonymous namespace to avoid
// ambiguity with conflicting identifiers that may have been defined in
// at namespace already.
namespace {
void resize_out(const Tensor &out, IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  TORCH_CHECK(options.dtype() == out.dtype(),
      "Expected out tensor to have dtype ", options.dtype(), ", but got ", out.dtype(), " instead");
  TORCH_CHECK(options.device() == out.device(),
      "Expected out tensor to have device ", options.device(), ", but got ", out.device(), " instead");
  const bool resized = at::native::resize_output(out, sizes);
  // Only restride if a resize occurred; otherwise we ignore the (advisory)
  // strides from the meta function and directly use the output tensor's
  // preexisting strides
  if (resized) {
    if (!strides.empty()) {
      TORCH_INTERNAL_ASSERT(!options.memory_format_opt().has_value());
      // TODO: avoid the redispatch here
      out.as_strided_(sizes, strides);
    } else if (options.memory_format_opt().has_value()) {
      out.unsafeGetTensorImpl()->empty_tensor_restride(*options.memory_format_opt());
    }
  }
}
void check_inplace(const Tensor &self, IntArrayRef sizes, const TensorOptions &options) {
  // These checks are needed on those operators that:
  //   1) don't use 'TensorIterator' (e.g. 'addmm' and 'baddbmm')
  //   2) have particular typing rules (e.g. 'cumsum' and 'cumprod')
  // For other operators (e.g. 'add'), 'TensorIterator' already checks
  // these things separately.
  TORCH_CHECK(options.dtype() == self.dtype(),
      "Bad in-place call: ",
      "input tensor dtype ", self.dtype(), " and output tensor dtype ", options.dtype(), " should match");
  TORCH_CHECK(options.device() == self.device(),
      "Bad in-place call: ",
      "input tensor device ", self.device(), " and output tensor device ", options.device(), " should match");
  TORCH_CHECK(sizes == self.sizes(),
      "Bad in-place call: ",
      "input tensor size ", self.sizes(), " and output tensor size ", sizes, " should match");
}
namespace {
at::Tensor wrapper_Lazy___adaptive_avg_pool2d(const at::Tensor & self, c10::SymIntArrayRef output_size) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_adaptive_avg_pool2d(self, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__adaptive_avg_pool2d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
  auto wrapper_Lazy_out__adaptive_avg_pool2d_out_tmp = wrapper_Lazy___adaptive_avg_pool2d(self, output_size);
  at::_copy_from_and_resize(wrapper_Lazy_out__adaptive_avg_pool2d_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___adaptive_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_adaptive_avg_pool2d_backward(grad_output, self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__adaptive_avg_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out__adaptive_avg_pool2d_backward_out_tmp = wrapper_Lazy___adaptive_avg_pool2d_backward(grad_output, self);
  at::_copy_from_and_resize(wrapper_Lazy_out__adaptive_avg_pool2d_backward_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___copy_from(const at::Tensor & self, const at::Tensor & dst, bool non_blocking) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_copy_from(self, dst, non_blocking);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__copy_from_out(const at::Tensor & self, const at::Tensor & dst, bool non_blocking, at::Tensor & out) {
  auto wrapper_Lazy_out__copy_from_out_tmp = wrapper_Lazy___copy_from(self, dst, non_blocking);
  at::_copy_from_and_resize(wrapper_Lazy_out__copy_from_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___copy_from_and_resize(const at::Tensor & self, const at::Tensor & dst) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_copy_from_and_resize(self, dst);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__copy_from_and_resize_out(const at::Tensor & self, const at::Tensor & dst, at::Tensor & out) {
  auto wrapper_Lazy_out__copy_from_and_resize_out_tmp = wrapper_Lazy___copy_from_and_resize(self, dst);
  at::_copy_from_and_resize(wrapper_Lazy_out__copy_from_and_resize_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___log_softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_log_softmax(self, dim, half_to_float);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__log_softmax_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
  auto wrapper_Lazy_out__log_softmax_out_tmp = wrapper_Lazy___log_softmax(self, dim, half_to_float);
  at::_copy_from_and_resize(wrapper_Lazy_out__log_softmax_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___log_softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_log_softmax_backward_data(grad_output, output, dim, input_dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__log_softmax_backward_data_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & out) {
  auto wrapper_Lazy_out__log_softmax_backward_data_out_tmp = wrapper_Lazy___log_softmax_backward_data(grad_output, output, dim, input_dtype);
  at::_copy_from_and_resize(wrapper_Lazy_out__log_softmax_backward_data_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___reshape_alias_copy(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_reshape_alias_copy_symint(self, size, stride);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__reshape_alias_copy_out(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto wrapper_Lazy_out__reshape_alias_copy_out_tmp = wrapper_Lazy___reshape_alias_copy(self, size, stride);
  at::_copy_from_and_resize(wrapper_Lazy_out__reshape_alias_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_softmax(self, dim, half_to_float);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__softmax_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
  auto wrapper_Lazy_out__softmax_out_tmp = wrapper_Lazy___softmax(self, dim, half_to_float);
  at::_copy_from_and_resize(wrapper_Lazy_out__softmax_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_softmax_backward_data(grad_output, output, dim, input_dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__softmax_backward_data_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & grad_input) {
  auto wrapper_Lazy_out__softmax_backward_data_out_tmp = wrapper_Lazy___softmax_backward_data(grad_output, output, dim, input_dtype);
  at::_copy_from_and_resize(wrapper_Lazy_out__softmax_backward_data_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy___to_copy(const at::Tensor & self, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, bool non_blocking, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_to_copy(self, dtype, layout, device, pin_memory, non_blocking, memory_format);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__to_copy_out(const at::Tensor & self, bool non_blocking, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto wrapper_Lazy_out__to_copy_out_tmp = wrapper_Lazy___to_copy(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, non_blocking, memory_format);
  at::_copy_from_and_resize(wrapper_Lazy_out__to_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___trilinear(const at::Tensor & i1, const at::Tensor & i2, const at::Tensor & i3, at::IntArrayRef expand1, at::IntArrayRef expand2, at::IntArrayRef expand3, at::IntArrayRef sumdim, int64_t unroll_dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_trilinear(i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__trilinear_out(const at::Tensor & i1, const at::Tensor & i2, const at::Tensor & i3, at::IntArrayRef expand1, at::IntArrayRef expand2, at::IntArrayRef expand3, at::IntArrayRef sumdim, int64_t unroll_dim, at::Tensor & out) {
  auto wrapper_Lazy_out__trilinear_out_tmp = wrapper_Lazy___trilinear(i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim);
  at::_copy_from_and_resize(wrapper_Lazy_out__trilinear_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy___unsafe_view(const at::Tensor & self, c10::SymIntArrayRef size) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::_unsafe_view(self, C10_AS_INTARRAYREF_SLOW(size));
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out__unsafe_view_out(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto wrapper_Lazy_out__unsafe_view_out_tmp = wrapper_Lazy___unsafe_view(self, size);
  at::_copy_from_and_resize(wrapper_Lazy_out__unsafe_view_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__abs(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::abs(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_abs_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_abs_out_tmp = wrapper_Lazy__abs(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_abs_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__abs_(at::Tensor & self) {
  auto wrapper_Lazy__abs__tmp = wrapper_Lazy__abs(self);
  at::_copy_from(wrapper_Lazy__abs__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_add(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::add(self, other, alpha);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_add_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_Lazy_out_add_out_tmp = wrapper_Lazy_Tensor_add(self, other, alpha);
  at::_copy_from_and_resize(wrapper_Lazy_out_add_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_add_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  auto wrapper_Lazy_Tensor_add__tmp = wrapper_Lazy_Tensor_add(self, other, alpha);
  at::_copy_from(wrapper_Lazy_Tensor_add__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__addcdiv(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::addcdiv(self, tensor1, tensor2, value);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_addcdiv_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_Lazy_out_addcdiv_out_tmp = wrapper_Lazy__addcdiv(self, tensor1, tensor2, value);
  at::_copy_from_and_resize(wrapper_Lazy_out_addcdiv_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__addcdiv_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  auto wrapper_Lazy__addcdiv__tmp = wrapper_Lazy__addcdiv(self, tensor1, tensor2, value);
  at::_copy_from(wrapper_Lazy__addcdiv__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__addcmul(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::addcmul(self, tensor1, tensor2, value);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_addcmul_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_Lazy_out_addcmul_out_tmp = wrapper_Lazy__addcmul(self, tensor1, tensor2, value);
  at::_copy_from_and_resize(wrapper_Lazy_out_addcmul_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__addcmul_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  auto wrapper_Lazy__addcmul__tmp = wrapper_Lazy__addcmul(self, tensor1, tensor2, value);
  at::_copy_from(wrapper_Lazy__addcmul__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::addmm(self, mat1, mat2, beta, alpha);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_addmm_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_Lazy_out_addmm_out_tmp = wrapper_Lazy__addmm(self, mat1, mat2, beta, alpha);
  at::_copy_from_and_resize(wrapper_Lazy_out_addmm_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
  auto wrapper_Lazy__addmm__tmp = wrapper_Lazy__addmm(self, mat1, mat2, beta, alpha);
  at::_copy_from(wrapper_Lazy__addmm__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__alias_copy(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::alias_copy(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_alias_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_alias_copy_out_tmp = wrapper_Lazy__alias_copy(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_alias_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__all(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::all(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_all_out_all_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_all_out_all_out_tmp = wrapper_Lazy__all(self);
  at::_copy_from_and_resize(wrapper_Lazy_all_out_all_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__any(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::any(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_all_out_any_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_all_out_any_out_tmp = wrapper_Lazy__any(self);
  at::_copy_from_and_resize(wrapper_Lazy_all_out_any_out_tmp, out);
  return out;
}
namespace {
at::Tensor & wrapper_Lazy_start_out_arange_out(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::arange_out(start, end, step, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy__as_strided_copy(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::as_strided_copy_symint(self, size, stride, storage_offset);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_as_strided_copy_out(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset, at::Tensor & out) {
  auto wrapper_Lazy_out_as_strided_copy_out_tmp = wrapper_Lazy__as_strided_copy(self, size, stride, storage_offset);
  at::_copy_from_and_resize(wrapper_Lazy_out_as_strided_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__as_strided_scatter(const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::as_strided_scatter_symint(self, src, size, stride, storage_offset);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_as_strided_scatter_out(const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset, at::Tensor & out) {
  auto wrapper_Lazy_out_as_strided_scatter_out_tmp = wrapper_Lazy__as_strided_scatter(self, src, size, stride, storage_offset);
  at::_copy_from_and_resize(wrapper_Lazy_out_as_strided_scatter_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__avg_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_avg_pool2d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
  auto wrapper_Lazy_out_avg_pool2d_out_tmp = wrapper_Lazy__avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
  at::_copy_from_and_resize(wrapper_Lazy_out_avg_pool2d_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_avg_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_avg_pool2d_backward_out_tmp = wrapper_Lazy__avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_avg_pool2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__baddbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::baddbmm(self, batch1, batch2, beta, alpha);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_baddbmm_out(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_Lazy_out_baddbmm_out_tmp = wrapper_Lazy__baddbmm(self, batch1, batch2, beta, alpha);
  at::_copy_from_and_resize(wrapper_Lazy_out_baddbmm_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__baddbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
  auto wrapper_Lazy__baddbmm__tmp = wrapper_Lazy__baddbmm(self, batch1, batch2, beta, alpha);
  at::_copy_from(wrapper_Lazy__baddbmm__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__bernoulli(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::bernoulli(self, generator);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_bernoulli_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Lazy_out_bernoulli_out_tmp = wrapper_Lazy__bernoulli(self, generator);
  at::_copy_from_and_resize(wrapper_Lazy_out_bernoulli_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_p_bernoulli(const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::bernoulli(self, p, generator);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_float_out_bernoulli_out(const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Lazy_float_out_bernoulli_out_tmp = wrapper_Lazy_p_bernoulli(self, p, generator);
  at::_copy_from_and_resize(wrapper_Lazy_float_out_bernoulli_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_float_bernoulli_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
  auto wrapper_Lazy_float_bernoulli__tmp = wrapper_Lazy_p_bernoulli(self, p, generator);
  at::_copy_from(wrapper_Lazy_float_bernoulli__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__binary_cross_entropy(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::binary_cross_entropy(self, target, weight, reduction);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_binary_cross_entropy_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
  auto wrapper_Lazy_out_binary_cross_entropy_out_tmp = wrapper_Lazy__binary_cross_entropy(self, target, weight, reduction);
  at::_copy_from_and_resize(wrapper_Lazy_out_binary_cross_entropy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__binary_cross_entropy_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::binary_cross_entropy_backward(grad_output, self, target, weight, reduction);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_binary_cross_entropy_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_binary_cross_entropy_backward_out_tmp = wrapper_Lazy__binary_cross_entropy_backward(grad_output, self, target, weight, reduction);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_binary_cross_entropy_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_bitwise_and(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::bitwise_and(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_bitwise_and_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_bitwise_and_out_tmp = wrapper_Lazy_Tensor_bitwise_and(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_bitwise_and_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_bitwise_and_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_bitwise_and__tmp = wrapper_Lazy_Tensor_bitwise_and(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_bitwise_and__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_bitwise_or(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::bitwise_or(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_bitwise_or_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_bitwise_or_out_tmp = wrapper_Lazy_Tensor_bitwise_or(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_bitwise_or_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_bitwise_or_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_bitwise_or__tmp = wrapper_Lazy_Tensor_bitwise_or(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_bitwise_or__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__block_diag(at::TensorList tensors) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::block_diag(tensors);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_block_diag_out(at::TensorList tensors, at::Tensor & out) {
  auto wrapper_Lazy_out_block_diag_out_tmp = wrapper_Lazy__block_diag(tensors);
  at::_copy_from_and_resize(wrapper_Lazy_out_block_diag_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__bmm(const at::Tensor & self, const at::Tensor & mat2) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::bmm(self, mat2);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_bmm_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
  auto wrapper_Lazy_out_bmm_out_tmp = wrapper_Lazy__bmm(self, mat2);
  at::_copy_from_and_resize(wrapper_Lazy_out_bmm_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__cat(const at::ITensorListRef & tensors, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::cat(tensors, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_cat_out(const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
  auto wrapper_Lazy_out_cat_out_tmp = wrapper_Lazy__cat(tensors, dim);
  at::_copy_from_and_resize(wrapper_Lazy_out_cat_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__clamp(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::clamp(self, min, max);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_clamp_out(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max, at::Tensor & out) {
  auto wrapper_Lazy_out_clamp_out_tmp = wrapper_Lazy__clamp(self, min, max);
  at::_copy_from_and_resize(wrapper_Lazy_out_clamp_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__clamp_(at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
  auto wrapper_Lazy__clamp__tmp = wrapper_Lazy__clamp(self, min, max);
  at::_copy_from(wrapper_Lazy__clamp__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__clamp_min(const at::Tensor & self, const at::Scalar & min) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::clamp_min(self, min);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_clamp_min_out(const at::Tensor & self, const at::Scalar & min, at::Tensor & out) {
  auto wrapper_Lazy_out_clamp_min_out_tmp = wrapper_Lazy__clamp_min(self, min);
  at::_copy_from_and_resize(wrapper_Lazy_out_clamp_min_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__clamp_min_(at::Tensor & self, const at::Scalar & min) {
  auto wrapper_Lazy__clamp_min__tmp = wrapper_Lazy__clamp_min(self, min);
  at::_copy_from(wrapper_Lazy__clamp_min__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__clone(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::clone(self, memory_format);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_clone_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto wrapper_Lazy_out_clone_out_tmp = wrapper_Lazy__clone(self, memory_format);
  at::_copy_from_and_resize(wrapper_Lazy_out_clone_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__constant_pad_nd(const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::constant_pad_nd(self, C10_AS_INTARRAYREF_SLOW(pad), value);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_constant_pad_nd_out(const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_Lazy_out_constant_pad_nd_out_tmp = wrapper_Lazy__constant_pad_nd(self, pad, value);
  at::_copy_from_and_resize(wrapper_Lazy_out_constant_pad_nd_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__convolution(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::convolution(input, weight, bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), transposed, C10_AS_INTARRAYREF_SLOW(output_padding), groups.expect_int());
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_convolution_out(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
  auto wrapper_Lazy_out_convolution_out_tmp = wrapper_Lazy__convolution(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
  at::_copy_from_and_resize(wrapper_Lazy_out_convolution_out_tmp, out);
  return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_Lazy__convolution_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::convolution_backward(grad_output, input, weight, bias_sizes.has_value() ? c10::make_optional(C10_AS_INTARRAYREF_SLOW(*bias_sizes)) : c10::nullopt, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), transposed, C10_AS_INTARRAYREF_SLOW(output_padding), groups.expect_int(), output_mask);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_Lazy_out_convolution_backward_out(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto wrapper_Lazy_out_convolution_backward_out_tmp = wrapper_Lazy__convolution_backward(grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_convolution_backward_out_tmp), out0);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_convolution_backward_out_tmp), out1);
  at::_copy_from_and_resize(std::get<2>(wrapper_Lazy_out_convolution_backward_out_tmp), out2);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}
namespace {
at::Tensor wrapper_Lazy__cos(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::cos(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_cos_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_cos_out_tmp = wrapper_Lazy__cos(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_cos_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__cos_(at::Tensor & self) {
  auto wrapper_Lazy__cos__tmp = wrapper_Lazy__cos(self);
  at::_copy_from(wrapper_Lazy__cos__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__cumsum(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::cumsum(self, dim, dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_cumsum_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_Lazy_out_cumsum_out_tmp = wrapper_Lazy__cumsum(self, dim, dtype);
  at::_copy_from_and_resize(wrapper_Lazy_out_cumsum_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__cumsum_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
  auto wrapper_Lazy__cumsum__tmp = wrapper_Lazy__cumsum(self, dim, dtype);
  at::_copy_from(wrapper_Lazy__cumsum__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__detach_copy(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::detach_copy(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_detach_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_detach_copy_out_tmp = wrapper_Lazy__detach_copy(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_detach_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__diag_embed(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::diag_embed(self, offset, dim1, dim2);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_diag_embed_out(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto wrapper_Lazy_out_diag_embed_out_tmp = wrapper_Lazy__diag_embed(self, offset, dim1, dim2);
  at::_copy_from_and_resize(wrapper_Lazy_out_diag_embed_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__diagonal_backward(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t offset, int64_t dim1, int64_t dim2) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::diagonal_backward_symint(grad_output, input_sizes, offset, dim1, dim2);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_diagonal_backward_out(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto wrapper_Lazy_out_diagonal_backward_out_tmp = wrapper_Lazy__diagonal_backward(grad_output, input_sizes, offset, dim1, dim2);
  at::_copy_from_and_resize(wrapper_Lazy_out_diagonal_backward_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__diagonal_copy(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::diagonal_copy(self, offset, dim1, dim2);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_diagonal_copy_out(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto wrapper_Lazy_out_diagonal_copy_out_tmp = wrapper_Lazy__diagonal_copy(self, offset, dim1, dim2);
  at::_copy_from_and_resize(wrapper_Lazy_out_diagonal_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__diagonal_scatter(const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::diagonal_scatter(self, src, offset, dim1, dim2);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_diagonal_scatter_out(const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto wrapper_Lazy_out_diagonal_scatter_out_tmp = wrapper_Lazy__diagonal_scatter(self, src, offset, dim1, dim2);
  at::_copy_from_and_resize(wrapper_Lazy_out_diagonal_scatter_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_div(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::div(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_div_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_out_div_out_tmp = wrapper_Lazy_Tensor_div(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_out_div_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_div_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_div__tmp = wrapper_Lazy_Tensor_div(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_div__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_mode_div(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::div(self, other, rounding_mode);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_mode_div_out(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
  auto wrapper_Lazy_out_mode_div_out_tmp = wrapper_Lazy_Tensor_mode_div(self, other, rounding_mode);
  at::_copy_from_and_resize(wrapper_Lazy_out_mode_div_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_mode_div_(at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
  auto wrapper_Lazy_Tensor_mode_div__tmp = wrapper_Lazy_Tensor_mode_div(self, other, rounding_mode);
  at::_copy_from(wrapper_Lazy_Tensor_mode_div__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__elu(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::elu(self, alpha, scale, input_scale);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_elu_out(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
  auto wrapper_Lazy_out_elu_out_tmp = wrapper_Lazy__elu(self, alpha, scale, input_scale);
  at::_copy_from_and_resize(wrapper_Lazy_out_elu_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__elu_(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
  auto wrapper_Lazy__elu__tmp = wrapper_Lazy__elu(self, alpha, scale, input_scale);
  at::_copy_from(wrapper_Lazy__elu__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__elu_backward(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_elu_backward_out(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_elu_backward_out_tmp = wrapper_Lazy__elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_elu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__embedding(const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::embedding(weight, indices, padding_idx.expect_int(), scale_grad_by_freq, sparse);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_embedding_out(const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse, at::Tensor & out) {
  auto wrapper_Lazy_out_embedding_out_tmp = wrapper_Lazy__embedding(weight, indices, padding_idx, scale_grad_by_freq, sparse);
  at::_copy_from_and_resize(wrapper_Lazy_out_embedding_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__embedding_dense_backward(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::embedding_dense_backward(grad_output, indices, num_weights.expect_int(), padding_idx.expect_int(), scale_grad_by_freq);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_embedding_dense_backward_out(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq, at::Tensor & out) {
  auto wrapper_Lazy_out_embedding_dense_backward_out_tmp = wrapper_Lazy__embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
  at::_copy_from_and_resize(wrapper_Lazy_out_embedding_dense_backward_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_memory_format_empty(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::empty_symint(size, dtype, layout, device, pin_memory, memory_format);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_empty_out(c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto wrapper_Lazy_out_empty_out_tmp = wrapper_Lazy_memory_format_empty(size, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
  at::_copy_from_and_resize(wrapper_Lazy_out_empty_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__empty_strided(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::empty_strided_symint(size, stride, dtype, layout, device, pin_memory);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_empty_strided_out(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto wrapper_Lazy_out_empty_strided_out_tmp = wrapper_Lazy__empty_strided(size, stride, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
  at::_copy_from_and_resize(wrapper_Lazy_out_empty_strided_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Scalar_eq(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::eq(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_eq_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_eq_out_tmp = wrapper_Lazy_Scalar_eq(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_eq_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_eq_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Lazy_Scalar_eq__tmp = wrapper_Lazy_Scalar_eq(self, other);
  at::_copy_from(wrapper_Lazy_Scalar_eq__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_eq(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::eq(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_eq_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_eq_out_tmp = wrapper_Lazy_Tensor_eq(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_eq_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_eq_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_eq__tmp = wrapper_Lazy_Tensor_eq(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_eq__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__exp(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::exp(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_exp_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_exp_out_tmp = wrapper_Lazy__exp(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_exp_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__exp_(at::Tensor & self) {
  auto wrapper_Lazy__exp__tmp = wrapper_Lazy__exp(self);
  at::_copy_from(wrapper_Lazy__exp__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__expand_copy(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::expand_copy_symint(self, size, implicit);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_expand_copy_out(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit, at::Tensor & out) {
  auto wrapper_Lazy_out_expand_copy_out_tmp = wrapper_Lazy__expand_copy(self, size, implicit);
  at::_copy_from_and_resize(wrapper_Lazy_out_expand_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor & wrapper_Lazy_Scalar_fill_(at::Tensor & self, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::fill_(self, value);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy__flip(const at::Tensor & self, at::IntArrayRef dims) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::flip(self, dims);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_flip_out(const at::Tensor & self, at::IntArrayRef dims, at::Tensor & out) {
  auto wrapper_Lazy_out_flip_out_tmp = wrapper_Lazy__flip(self, dims);
  at::_copy_from_and_resize(wrapper_Lazy_out_flip_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__floor(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::floor(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_floor_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_floor_out_tmp = wrapper_Lazy__floor(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_floor_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__floor_(at::Tensor & self) {
  auto wrapper_Lazy__floor__tmp = wrapper_Lazy__floor(self);
  at::_copy_from(wrapper_Lazy__floor__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__frac(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::frac(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_frac_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_frac_out_tmp = wrapper_Lazy__frac(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_frac_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__frac_(at::Tensor & self) {
  auto wrapper_Lazy__frac__tmp = wrapper_Lazy__frac(self);
  at::_copy_from(wrapper_Lazy__frac__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__gather(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::gather(self, dim, index, sparse_grad);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_gather_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad, at::Tensor & out) {
  auto wrapper_Lazy_out_gather_out_tmp = wrapper_Lazy__gather(self, dim, index, sparse_grad);
  at::_copy_from_and_resize(wrapper_Lazy_out_gather_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Scalar_ge(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::ge(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_ge_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_ge_out_tmp = wrapper_Lazy_Scalar_ge(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_ge_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_ge_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Lazy_Scalar_ge__tmp = wrapper_Lazy_Scalar_ge(self, other);
  at::_copy_from(wrapper_Lazy_Scalar_ge__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_ge(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::ge(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_ge_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_ge_out_tmp = wrapper_Lazy_Tensor_ge(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_ge_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_ge_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_ge__tmp = wrapper_Lazy_Tensor_ge(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_ge__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__gelu(const at::Tensor & self, c10::string_view approximate) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::gelu(self, approximate);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_gelu_out(const at::Tensor & self, c10::string_view approximate, at::Tensor & out) {
  auto wrapper_Lazy_out_gelu_out_tmp = wrapper_Lazy__gelu(self, approximate);
  at::_copy_from_and_resize(wrapper_Lazy_out_gelu_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__gelu_(at::Tensor & self, c10::string_view approximate) {
  auto wrapper_Lazy__gelu__tmp = wrapper_Lazy__gelu(self, approximate);
  at::_copy_from(wrapper_Lazy__gelu__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__gelu_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::gelu_backward(grad_output, self, approximate);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_gelu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_gelu_backward_out_tmp = wrapper_Lazy__gelu_backward(grad_output, self, approximate);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_gelu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__glu(const at::Tensor & self, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::glu(self, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_glu_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
  auto wrapper_Lazy_out_glu_out_tmp = wrapper_Lazy__glu(self, dim);
  at::_copy_from_and_resize(wrapper_Lazy_out_glu_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__glu_backward(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::glu_backward(grad_output, self, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_glu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_glu_backward_out_tmp = wrapper_Lazy__glu_backward(grad_output, self, dim);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_glu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__glu_jvp(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::glu_jvp(glu, x, dx, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_glu_jvp_out(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim, at::Tensor & out) {
  auto wrapper_Lazy_out_glu_jvp_out_tmp = wrapper_Lazy__glu_jvp(glu, x, dx, dim);
  at::_copy_from_and_resize(wrapper_Lazy_out_glu_jvp_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__grid_sampler_2d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::grid_sampler_2d(input, grid, interpolation_mode, padding_mode, align_corners);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_grid_sampler_2d_out(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, at::Tensor & out) {
  auto wrapper_Lazy_out_grid_sampler_2d_out_tmp = wrapper_Lazy__grid_sampler_2d(input, grid, interpolation_mode, padding_mode, align_corners);
  at::_copy_from_and_resize(wrapper_Lazy_out_grid_sampler_2d_out_tmp, out);
  return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__grid_sampler_2d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::grid_sampler_2d_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_out_grid_sampler_2d_backward_out(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
  auto wrapper_Lazy_out_grid_sampler_2d_backward_out_tmp = wrapper_Lazy__grid_sampler_2d_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_grid_sampler_2d_backward_out_tmp), out0);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_grid_sampler_2d_backward_out_tmp), out1);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}
namespace {
at::Tensor wrapper_Lazy_Scalar_gt(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::gt(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_gt_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_gt_out_tmp = wrapper_Lazy_Scalar_gt(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_gt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_gt_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Lazy_Scalar_gt__tmp = wrapper_Lazy_Scalar_gt(self, other);
  at::_copy_from(wrapper_Lazy_Scalar_gt__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_gt(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::gt(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_gt_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_gt_out_tmp = wrapper_Lazy_Tensor_gt(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_gt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_gt_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_gt__tmp = wrapper_Lazy_Tensor_gt(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_gt__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__hardsigmoid(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::hardsigmoid(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_hardsigmoid_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_hardsigmoid_out_tmp = wrapper_Lazy__hardsigmoid(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_hardsigmoid_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__hardsigmoid_(at::Tensor & self) {
  auto wrapper_Lazy__hardsigmoid__tmp = wrapper_Lazy__hardsigmoid(self);
  at::_copy_from(wrapper_Lazy__hardsigmoid__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::index_select(self, dim, index);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_index_select_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
  auto wrapper_Lazy_out_index_select_out_tmp = wrapper_Lazy__index_select(self, dim, index);
  at::_copy_from_and_resize(wrapper_Lazy_out_index_select_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Scalar_le(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::le(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_le_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_le_out_tmp = wrapper_Lazy_Scalar_le(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_le_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_le_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Lazy_Scalar_le__tmp = wrapper_Lazy_Scalar_le(self, other);
  at::_copy_from(wrapper_Lazy_Scalar_le__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_le(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::le(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_le_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_le_out_tmp = wrapper_Lazy_Tensor_le(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_le_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_le_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_le__tmp = wrapper_Lazy_Tensor_le(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_le__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__leaky_relu(const at::Tensor & self, const at::Scalar & negative_slope) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::leaky_relu(self, negative_slope);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_leaky_relu_out(const at::Tensor & self, const at::Scalar & negative_slope, at::Tensor & out) {
  auto wrapper_Lazy_out_leaky_relu_out_tmp = wrapper_Lazy__leaky_relu(self, negative_slope);
  at::_copy_from_and_resize(wrapper_Lazy_out_leaky_relu_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__leaky_relu_(at::Tensor & self, const at::Scalar & negative_slope) {
  auto wrapper_Lazy__leaky_relu__tmp = wrapper_Lazy__leaky_relu(self, negative_slope);
  at::_copy_from(wrapper_Lazy__leaky_relu__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__leaky_relu_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::leaky_relu_backward(grad_output, self, negative_slope, self_is_result);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_leaky_relu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_leaky_relu_backward_out_tmp = wrapper_Lazy__leaky_relu_backward(grad_output, self, negative_slope, self_is_result);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_leaky_relu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__lift(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::lift(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_lift_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_lift_out_tmp = wrapper_Lazy__lift(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_lift_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__lift_fresh(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::lift_fresh(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy_atol_rtol_tensor_linalg_pinv(const at::Tensor & self, const c10::optional<at::Tensor> & atol, const c10::optional<at::Tensor> & rtol, bool hermitian) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::linalg_pinv(self, atol, rtol, hermitian);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_atol_rtol_tensor_out_linalg_pinv_out(const at::Tensor & self, const c10::optional<at::Tensor> & atol, const c10::optional<at::Tensor> & rtol, bool hermitian, at::Tensor & out) {
  auto wrapper_Lazy_atol_rtol_tensor_out_linalg_pinv_out_tmp = wrapper_Lazy_atol_rtol_tensor_linalg_pinv(self, atol, rtol, hermitian);
  at::_copy_from_and_resize(wrapper_Lazy_atol_rtol_tensor_out_linalg_pinv_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__log(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::log(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_log_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_log_out_tmp = wrapper_Lazy__log(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_log_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__log_(at::Tensor & self) {
  auto wrapper_Lazy__log__tmp = wrapper_Lazy__log(self);
  at::_copy_from(wrapper_Lazy__log__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__log2(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::log2(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_log2_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_log2_out_tmp = wrapper_Lazy__log2(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_log2_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__log2_(at::Tensor & self) {
  auto wrapper_Lazy__log2__tmp = wrapper_Lazy__log2(self);
  at::_copy_from(wrapper_Lazy__log2__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__log_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::log_sigmoid_backward(grad_output, self, buffer);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_log_sigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_log_sigmoid_backward_out_tmp = wrapper_Lazy__log_sigmoid_backward(grad_output, self, buffer);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_log_sigmoid_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__log_sigmoid_forward(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::log_sigmoid_forward(self);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_output_log_sigmoid_forward_out(const at::Tensor & self, at::Tensor & output, at::Tensor & buffer) {
  auto wrapper_Lazy_output_log_sigmoid_forward_out_tmp = wrapper_Lazy__log_sigmoid_forward(self);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_output_log_sigmoid_forward_out_tmp), output);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_output_log_sigmoid_forward_out_tmp), buffer);
  return ::std::tuple<at::Tensor &,at::Tensor &>(output, buffer);
}
namespace {
at::Tensor wrapper_Lazy__logdet(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::logdet(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_Lazy_out_logsumexp_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::logsumexp_out(self, dim, keepdim, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy_Scalar_lt(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::lt(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_lt_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_lt_out_tmp = wrapper_Lazy_Scalar_lt(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_lt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_lt_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Lazy_Scalar_lt__tmp = wrapper_Lazy_Scalar_lt(self, other);
  at::_copy_from(wrapper_Lazy_Scalar_lt__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_lt(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::lt(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_lt_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_lt_out_tmp = wrapper_Lazy_Tensor_lt(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_lt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_lt_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_lt__tmp = wrapper_Lazy_Tensor_lt(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_lt__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Scalar_masked_fill(const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::masked_fill(self, mask, value);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_masked_fill_out(const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_masked_fill_out_tmp = wrapper_Lazy_Scalar_masked_fill(self, mask, value);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_masked_fill_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
  auto wrapper_Lazy_Scalar_masked_fill__tmp = wrapper_Lazy_Scalar_masked_fill(self, mask, value);
  at::_copy_from(wrapper_Lazy_Scalar_masked_fill__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_masked_fill(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::masked_fill(self, mask, value);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_masked_fill_out(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_masked_fill_out_tmp = wrapper_Lazy_Tensor_masked_fill(self, mask, value);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_masked_fill_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
  auto wrapper_Lazy_Tensor_masked_fill__tmp = wrapper_Lazy_Tensor_masked_fill(self, mask, value);
  at::_copy_from(wrapper_Lazy_Tensor_masked_fill__tmp, self);
  return self;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy_dim_max(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::max(self, dim, keepdim);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_dim_max_max_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
  auto wrapper_Lazy_dim_max_max_out_tmp = wrapper_Lazy_dim_max(self, dim, keepdim);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_dim_max_max_out_tmp), max);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_dim_max_max_out_tmp), max_values);
  return ::std::tuple<at::Tensor &,at::Tensor &>(max, max_values);
}
namespace {
at::Tensor wrapper_Lazy__max(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::max(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_unary_out_max_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_unary_out_max_out_tmp = wrapper_Lazy__max(self);
  at::_copy_from_and_resize(wrapper_Lazy_unary_out_max_out_tmp, out);
  return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__max_pool2d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_out_max_pool2d_with_indices_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
  auto wrapper_Lazy_out_max_pool2d_with_indices_out_tmp = wrapper_Lazy__max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_max_pool2d_with_indices_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_max_pool2d_with_indices_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out, indices);
}
namespace {
at::Tensor wrapper_Lazy__max_pool2d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_max_pool2d_with_indices_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_max_pool2d_with_indices_backward_out_tmp = wrapper_Lazy__max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_max_pool2d_with_indices_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__max_pool3d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_out_max_pool3d_with_indices_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
  auto wrapper_Lazy_out_max_pool3d_with_indices_out_tmp = wrapper_Lazy__max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_max_pool3d_with_indices_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_max_pool3d_with_indices_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out, indices);
}
namespace {
at::Tensor wrapper_Lazy__max_pool3d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_max_pool3d_with_indices_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_max_pool3d_with_indices_backward_out_tmp = wrapper_Lazy__max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_max_pool3d_with_indices_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__maximum(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::maximum(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_maximum_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_out_maximum_out_tmp = wrapper_Lazy__maximum(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_out_maximum_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__mean(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::mean(self, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy_dim_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::mean(self, dim, keepdim, dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_mean_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_Lazy_out_mean_out_tmp = wrapper_Lazy_dim_mean(self, dim, keepdim, dtype);
  at::_copy_from_and_resize(wrapper_Lazy_out_mean_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__min(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::min(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_unary_out_min_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_unary_out_min_out_tmp = wrapper_Lazy__min(self);
  at::_copy_from_and_resize(wrapper_Lazy_unary_out_min_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__minimum(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::minimum(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_minimum_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_out_minimum_out_tmp = wrapper_Lazy__minimum(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_out_minimum_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__mm(const at::Tensor & self, const at::Tensor & mat2) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::mm(self, mat2);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_mm_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
  auto wrapper_Lazy_out_mm_out_tmp = wrapper_Lazy__mm(self, mat2);
  at::_copy_from_and_resize(wrapper_Lazy_out_mm_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_mul(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::mul(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_mul_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_out_mul_out_tmp = wrapper_Lazy_Tensor_mul(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_out_mul_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_mul_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_mul__tmp = wrapper_Lazy_Tensor_mul(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_mul__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__mv(const at::Tensor & self, const at::Tensor & vec) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::mv(self, vec);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_mv_out(const at::Tensor & self, const at::Tensor & vec, at::Tensor & out) {
  auto wrapper_Lazy_out_mv_out_tmp = wrapper_Lazy__mv(self, vec);
  at::_copy_from_and_resize(wrapper_Lazy_out_mv_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__narrow_copy(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::narrow_copy_symint(self, dim, start, length);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_narrow_copy_out(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length, at::Tensor & out) {
  auto wrapper_Lazy_out_narrow_copy_out_tmp = wrapper_Lazy__narrow_copy(self, dim, start, length);
  at::_copy_from_and_resize(wrapper_Lazy_out_narrow_copy_out_tmp, out);
  return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_Lazy__native_batch_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_Lazy_out_native_batch_norm_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
  auto wrapper_Lazy_out_native_batch_norm_out_tmp = wrapper_Lazy__native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_native_batch_norm_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_native_batch_norm_out_tmp), save_mean);
  at::_copy_from_and_resize(std::get<2>(wrapper_Lazy_out_native_batch_norm_out_tmp), save_invstd);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out, save_mean, save_invstd);
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_Lazy__native_batch_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::native_batch_norm_backward(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_Lazy_out_native_batch_norm_backward_out(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto wrapper_Lazy_out_native_batch_norm_backward_out_tmp = wrapper_Lazy__native_batch_norm_backward(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_native_batch_norm_backward_out_tmp), out0);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_native_batch_norm_backward_out_tmp), out1);
  at::_copy_from_and_resize(std::get<2>(wrapper_Lazy_out_native_batch_norm_backward_out_tmp), out2);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__native_dropout(const at::Tensor & input, double p, c10::optional<bool> train) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::native_dropout(input, p, train);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_out_native_dropout_out(const at::Tensor & input, double p, c10::optional<bool> train, at::Tensor & out0, at::Tensor & out1) {
  auto wrapper_Lazy_out_native_dropout_out_tmp = wrapper_Lazy__native_dropout(input, p, train);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_native_dropout_out_tmp), out0);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_native_dropout_out_tmp), out1);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}
namespace {
at::Tensor wrapper_Lazy__native_dropout_backward(const at::Tensor & grad_output, const at::Tensor & mask, double scale) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::native_dropout_backward(grad_output, mask, scale);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_native_dropout_backward_out(const at::Tensor & grad_output, const at::Tensor & mask, double scale, at::Tensor & out) {
  auto wrapper_Lazy_out_native_dropout_backward_out_tmp = wrapper_Lazy__native_dropout_backward(grad_output, mask, scale);
  at::_copy_from_and_resize(wrapper_Lazy_out_native_dropout_backward_out_tmp, out);
  return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_Lazy__native_layer_norm(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::native_layer_norm(input, C10_AS_INTARRAYREF_SLOW(normalized_shape), weight, bias, eps);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_Lazy_out_native_layer_norm_out(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto wrapper_Lazy_out_native_layer_norm_out_tmp = wrapper_Lazy__native_layer_norm(input, normalized_shape, weight, bias, eps);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_native_layer_norm_out_tmp), out0);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_native_layer_norm_out_tmp), out1);
  at::_copy_from_and_resize(std::get<2>(wrapper_Lazy_out_native_layer_norm_out_tmp), out2);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_Lazy__native_layer_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::native_layer_norm_backward(grad_out, input, C10_AS_INTARRAYREF_SLOW(normalized_shape), mean, rstd, weight, bias, output_mask);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_Lazy_out_native_layer_norm_backward_out(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto wrapper_Lazy_out_native_layer_norm_backward_out_tmp = wrapper_Lazy__native_layer_norm_backward(grad_out, input, normalized_shape, mean, rstd, weight, bias, output_mask);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_out_native_layer_norm_backward_out_tmp), out0);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_out_native_layer_norm_backward_out_tmp), out1);
  at::_copy_from_and_resize(std::get<2>(wrapper_Lazy_out_native_layer_norm_backward_out_tmp), out2);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}
namespace {
at::Tensor wrapper_Lazy_Scalar_ne(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::ne(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Scalar_out_ne_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Lazy_Scalar_out_ne_out_tmp = wrapper_Lazy_Scalar_ne(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Scalar_out_ne_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_ne_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Lazy_Scalar_ne__tmp = wrapper_Lazy_Scalar_ne(self, other);
  at::_copy_from(wrapper_Lazy_Scalar_ne__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_ne(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::ne(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_ne_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_ne_out_tmp = wrapper_Lazy_Tensor_ne(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_ne_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_ne_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_ne__tmp = wrapper_Lazy_Tensor_ne(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_ne__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__neg(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::neg(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_neg_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_neg_out_tmp = wrapper_Lazy__neg(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_neg_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__neg_(at::Tensor & self) {
  auto wrapper_Lazy__neg__tmp = wrapper_Lazy__neg(self);
  at::_copy_from(wrapper_Lazy__neg__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__new_empty_strided(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::new_empty_strided_symint(self, size, stride, dtype, layout, device, pin_memory);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_new_empty_strided_out(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto wrapper_Lazy_out_new_empty_strided_out_tmp = wrapper_Lazy__new_empty_strided(self, size, stride, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
  at::_copy_from_and_resize(wrapper_Lazy_out_new_empty_strided_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__nll_loss2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index.expect_int(), total_weight);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_nll_loss2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_nll_loss2d_backward_out_tmp = wrapper_Lazy__nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_nll_loss2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__nll_loss2d_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::nll_loss2d_forward(self, target, weight, reduction, ignore_index.expect_int());
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_output_nll_loss2d_forward_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
  auto wrapper_Lazy_output_nll_loss2d_forward_out_tmp = wrapper_Lazy__nll_loss2d_forward(self, target, weight, reduction, ignore_index);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_output_nll_loss2d_forward_out_tmp), output);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_output_nll_loss2d_forward_out_tmp), total_weight);
  return ::std::tuple<at::Tensor &,at::Tensor &>(output, total_weight);
}
namespace {
at::Tensor wrapper_Lazy__nll_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index.expect_int(), total_weight);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_nll_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_nll_loss_backward_out_tmp = wrapper_Lazy__nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_nll_loss_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__nll_loss_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::nll_loss_forward(self, target, weight, reduction, ignore_index.expect_int());
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_output_nll_loss_forward_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
  auto wrapper_Lazy_output_nll_loss_forward_out_tmp = wrapper_Lazy__nll_loss_forward(self, target, weight, reduction, ignore_index);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_output_nll_loss_forward_out_tmp), output);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_output_nll_loss_forward_out_tmp), total_weight);
  return ::std::tuple<at::Tensor &,at::Tensor &>(output, total_weight);
}
namespace {
at::Tensor wrapper_Lazy__nonzero(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::nonzero(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_nonzero_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_nonzero_out_tmp = wrapper_Lazy__nonzero(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_nonzero_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_ScalarOpt_dim_norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::norm(self, p, dim, keepdim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_norm_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
  auto wrapper_Lazy_out_norm_out_tmp = wrapper_Lazy_ScalarOpt_dim_norm(self, p, dim, keepdim);
  at::_copy_from_and_resize(wrapper_Lazy_out_norm_out_tmp, out);
  return out;
}
namespace {
at::Tensor & wrapper_Lazy__normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::normal_(self, mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy__permute_copy(const at::Tensor & self, at::IntArrayRef dims) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::permute_copy(self, dims);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_permute_copy_out(const at::Tensor & self, at::IntArrayRef dims, at::Tensor & out) {
  auto wrapper_Lazy_out_permute_copy_out_tmp = wrapper_Lazy__permute_copy(self, dims);
  at::_copy_from_and_resize(wrapper_Lazy_out_permute_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__pixel_shuffle(const at::Tensor & self, int64_t upscale_factor) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::pixel_shuffle(self, upscale_factor);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_pixel_shuffle_out(const at::Tensor & self, int64_t upscale_factor, at::Tensor & out) {
  auto wrapper_Lazy_out_pixel_shuffle_out_tmp = wrapper_Lazy__pixel_shuffle(self, upscale_factor);
  at::_copy_from_and_resize(wrapper_Lazy_out_pixel_shuffle_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__pixel_unshuffle(const at::Tensor & self, int64_t downscale_factor) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::pixel_unshuffle(self, downscale_factor);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_pixel_unshuffle_out(const at::Tensor & self, int64_t downscale_factor, at::Tensor & out) {
  auto wrapper_Lazy_out_pixel_unshuffle_out_tmp = wrapper_Lazy__pixel_unshuffle(self, downscale_factor);
  at::_copy_from_and_resize(wrapper_Lazy_out_pixel_unshuffle_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_Tensor_pow(const at::Tensor & self, const at::Tensor & exponent) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::pow(self, exponent);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_Tensor_out_pow_out(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_Tensor_out_pow_out_tmp = wrapper_Lazy_Tensor_Tensor_pow(self, exponent);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_Tensor_out_pow_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_pow_(at::Tensor & self, const at::Tensor & exponent) {
  auto wrapper_Lazy_Tensor_pow__tmp = wrapper_Lazy_Tensor_Tensor_pow(self, exponent);
  at::_copy_from(wrapper_Lazy_Tensor_pow__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_Scalar_pow(const at::Tensor & self, const at::Scalar & exponent) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::pow(self, exponent);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_Scalar_out_pow_out(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_Scalar_out_pow_out_tmp = wrapper_Lazy_Tensor_Scalar_pow(self, exponent);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_Scalar_out_pow_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Scalar_pow_(at::Tensor & self, const at::Scalar & exponent) {
  auto wrapper_Lazy_Scalar_pow__tmp = wrapper_Lazy_Tensor_Scalar_pow(self, exponent);
  at::_copy_from(wrapper_Lazy_Scalar_pow__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_from_random(const at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::random(self, from, to, generator);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_from_out_random_out(const at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Lazy_from_out_random_out_tmp = wrapper_Lazy_from_random(self, from, to, generator);
  at::_copy_from_and_resize(wrapper_Lazy_from_out_random_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_from_random_(at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
  auto wrapper_Lazy_from_random__tmp = wrapper_Lazy_from_random(self, from, to, generator);
  at::_copy_from(wrapper_Lazy_from_random__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_to_random(const at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::random(self, to, generator);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_to_out_random_out(const at::Tensor & self, int64_t to, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Lazy_to_out_random_out_tmp = wrapper_Lazy_to_random(self, to, generator);
  at::_copy_from_and_resize(wrapper_Lazy_to_out_random_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_to_random_(at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
  auto wrapper_Lazy_to_random__tmp = wrapper_Lazy_to_random(self, to, generator);
  at::_copy_from(wrapper_Lazy_to_random__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__random(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::random(self, generator);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_random_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Lazy_out_random_out_tmp = wrapper_Lazy__random(self, generator);
  at::_copy_from_and_resize(wrapper_Lazy_out_random_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__random_(at::Tensor & self, c10::optional<at::Generator> generator) {
  auto wrapper_Lazy__random__tmp = wrapper_Lazy__random(self, generator);
  at::_copy_from(wrapper_Lazy__random__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__reciprocal(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::reciprocal(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_reciprocal_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_reciprocal_out_tmp = wrapper_Lazy__reciprocal(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_reciprocal_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__reciprocal_(at::Tensor & self) {
  auto wrapper_Lazy__reciprocal__tmp = wrapper_Lazy__reciprocal(self);
  at::_copy_from(wrapper_Lazy__reciprocal__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__relu(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::relu(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_relu_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_relu_out_tmp = wrapper_Lazy__relu(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_relu_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__relu_(at::Tensor & self) {
  auto wrapper_Lazy__relu__tmp = wrapper_Lazy__relu(self);
  at::_copy_from(wrapper_Lazy__relu__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_remainder(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::remainder(self, other);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_remainder_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_remainder_out_tmp = wrapper_Lazy_Tensor_remainder(self, other);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_remainder_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_remainder_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Lazy_Tensor_remainder__tmp = wrapper_Lazy_Tensor_remainder(self, other);
  at::_copy_from(wrapper_Lazy_Tensor_remainder__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__repeat(const at::Tensor & self, c10::SymIntArrayRef repeats) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::repeat(self, C10_AS_INTARRAYREF_SLOW(repeats));
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_repeat_out(const at::Tensor & self, c10::SymIntArrayRef repeats, at::Tensor & out) {
  auto wrapper_Lazy_out_repeat_out_tmp = wrapper_Lazy__repeat(self, repeats);
  at::_copy_from_and_resize(wrapper_Lazy_out_repeat_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__rsqrt(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::rsqrt(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_rsqrt_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_rsqrt_out_tmp = wrapper_Lazy__rsqrt(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_rsqrt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__rsqrt_(at::Tensor & self) {
  auto wrapper_Lazy__rsqrt__tmp = wrapper_Lazy__rsqrt(self);
  at::_copy_from(wrapper_Lazy__rsqrt__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__scatter_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::scatter_add(self, dim, index, src);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_scatter_add_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
  auto wrapper_Lazy_out_scatter_add_out_tmp = wrapper_Lazy__scatter_add(self, dim, index, src);
  at::_copy_from_and_resize(wrapper_Lazy_out_scatter_add_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__scatter_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
  auto wrapper_Lazy__scatter_add__tmp = wrapper_Lazy__scatter_add(self, dim, index, src);
  at::_copy_from(wrapper_Lazy__scatter_add__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__select_backward(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t dim, c10::SymInt index) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::select_backward_symint(grad_output, input_sizes, dim, index);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_select_backward_out(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t dim, c10::SymInt index, at::Tensor & out) {
  auto wrapper_Lazy_out_select_backward_out_tmp = wrapper_Lazy__select_backward(grad_output, input_sizes, dim, index);
  at::_copy_from_and_resize(wrapper_Lazy_out_select_backward_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_int_select_copy(const at::Tensor & self, int64_t dim, c10::SymInt index) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::select_copy(self, dim, index.expect_int());
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_int_out_select_copy_out(const at::Tensor & self, int64_t dim, c10::SymInt index, at::Tensor & out) {
  auto wrapper_Lazy_int_out_select_copy_out_tmp = wrapper_Lazy_int_select_copy(self, dim, index);
  at::_copy_from_and_resize(wrapper_Lazy_int_out_select_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__select_scatter(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::select_scatter(self, src, dim, index.expect_int());
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_select_scatter_out(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index, at::Tensor & out) {
  auto wrapper_Lazy_out_select_scatter_out_tmp = wrapper_Lazy__select_scatter(self, src, dim, index);
  at::_copy_from_and_resize(wrapper_Lazy_out_select_scatter_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__sgn(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sgn(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_sgn_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_sgn_out_tmp = wrapper_Lazy__sgn(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_sgn_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__sgn_(at::Tensor & self) {
  auto wrapper_Lazy__sgn__tmp = wrapper_Lazy__sgn(self);
  at::_copy_from(wrapper_Lazy__sgn__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__sigmoid(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sigmoid(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_sigmoid_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_sigmoid_out_tmp = wrapper_Lazy__sigmoid(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_sigmoid_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__sigmoid_(at::Tensor & self) {
  auto wrapper_Lazy__sigmoid__tmp = wrapper_Lazy__sigmoid(self);
  at::_copy_from(wrapper_Lazy__sigmoid__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & output) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sigmoid_backward(grad_output, output);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_sigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_sigmoid_backward_out_tmp = wrapper_Lazy__sigmoid_backward(grad_output, output);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_sigmoid_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__silu(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::silu(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_silu_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_silu_out_tmp = wrapper_Lazy__silu(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_silu_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__silu_(at::Tensor & self) {
  auto wrapper_Lazy__silu__tmp = wrapper_Lazy__silu(self);
  at::_copy_from(wrapper_Lazy__silu__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__slice_backward(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t dim, c10::SymInt start, c10::SymInt end, c10::SymInt step) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::slice_backward_symint(grad_output, input_sizes, dim, start, end, step);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_slice_backward_out(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t dim, c10::SymInt start, c10::SymInt end, c10::SymInt step, at::Tensor & out) {
  auto wrapper_Lazy_out_slice_backward_out_tmp = wrapper_Lazy__slice_backward(grad_output, input_sizes, dim, start, end, step);
  at::_copy_from_and_resize(wrapper_Lazy_out_slice_backward_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_slice_copy(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::slice_copy_symint(self, dim, start, end, step);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_Tensor_out_slice_copy_out(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step, at::Tensor & out) {
  auto wrapper_Lazy_Tensor_out_slice_copy_out_tmp = wrapper_Lazy_Tensor_slice_copy(self, dim, start, end, step);
  at::_copy_from_and_resize(wrapper_Lazy_Tensor_out_slice_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__slice_scatter(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::slice_scatter_symint(self, src, dim, start, end, step);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_slice_scatter_out(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step, at::Tensor & out) {
  auto wrapper_Lazy_out_slice_scatter_out_tmp = wrapper_Lazy__slice_scatter(self, src, dim, start, end, step);
  at::_copy_from_and_resize(wrapper_Lazy_out_slice_scatter_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__smooth_l1_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::smooth_l1_loss(self, target, reduction, beta);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_smooth_l1_loss_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
  auto wrapper_Lazy_out_smooth_l1_loss_out_tmp = wrapper_Lazy__smooth_l1_loss(self, target, reduction, beta);
  at::_copy_from_and_resize(wrapper_Lazy_out_smooth_l1_loss_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__smooth_l1_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::smooth_l1_loss_backward(grad_output, self, target, reduction, beta);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_smooth_l1_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_smooth_l1_loss_backward_out_tmp = wrapper_Lazy__smooth_l1_loss_backward(grad_output, self, target, reduction, beta);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_smooth_l1_loss_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__softplus(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::softplus(self, beta, threshold);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_softplus_out(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
  auto wrapper_Lazy_out_softplus_out_tmp = wrapper_Lazy__softplus(self, beta, threshold);
  at::_copy_from_and_resize(wrapper_Lazy_out_softplus_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__softplus_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::softplus_backward(grad_output, self, beta, threshold);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_softplus_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_softplus_backward_out_tmp = wrapper_Lazy__softplus_backward(grad_output, self, beta, threshold);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_softplus_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__sort(const at::Tensor & self, int64_t dim, bool descending) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sort(self, dim, descending);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_values_sort_out(const at::Tensor & self, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
  auto wrapper_Lazy_values_sort_out_tmp = wrapper_Lazy__sort(self, dim, descending);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_values_sort_out_tmp), values);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_values_sort_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(values, indices);
}
namespace {
at::Tensor wrapper_Lazy__sqrt(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sqrt(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_sqrt_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_sqrt_out_tmp = wrapper_Lazy__sqrt(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_sqrt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__sqrt_(at::Tensor & self) {
  auto wrapper_Lazy__sqrt__tmp = wrapper_Lazy__sqrt(self);
  at::_copy_from(wrapper_Lazy__sqrt__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__squeeze_copy(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::squeeze_copy(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_squeeze_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_squeeze_copy_out_tmp = wrapper_Lazy__squeeze_copy(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_squeeze_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_dim_squeeze_copy(const at::Tensor & self, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::squeeze_copy(self, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_dim_out_squeeze_copy_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
  auto wrapper_Lazy_dim_out_squeeze_copy_out_tmp = wrapper_Lazy_dim_squeeze_copy(self, dim);
  at::_copy_from_and_resize(wrapper_Lazy_dim_out_squeeze_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_dims_squeeze_copy(const at::Tensor & self, at::IntArrayRef dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::squeeze_copy(self, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_dims_out_squeeze_copy_out(const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
  auto wrapper_Lazy_dims_out_squeeze_copy_out_tmp = wrapper_Lazy_dims_squeeze_copy(self, dim);
  at::_copy_from_and_resize(wrapper_Lazy_dims_out_squeeze_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__stack(at::TensorList tensors, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::stack(tensors, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_stack_out(at::TensorList tensors, int64_t dim, at::Tensor & out) {
  auto wrapper_Lazy_out_stack_out_tmp = wrapper_Lazy__stack(tensors, dim);
  at::_copy_from_and_resize(wrapper_Lazy_out_stack_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__std(const at::Tensor & self, bool unbiased) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::std(self, unbiased);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_Lazy_dim_std(const at::Tensor & self, at::OptionalIntArrayRef dim, bool unbiased, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::std(self, dim, unbiased, keepdim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_std_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool unbiased, bool keepdim, at::Tensor & out) {
  auto wrapper_Lazy_out_std_out_tmp = wrapper_Lazy_dim_std(self, dim, unbiased, keepdim);
  at::_copy_from_and_resize(wrapper_Lazy_out_std_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_correction_std(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::std(self, dim, correction, keepdim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_correction_out_std_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
  auto wrapper_Lazy_correction_out_std_out_tmp = wrapper_Lazy_correction_std(self, dim, correction, keepdim);
  at::_copy_from_and_resize(wrapper_Lazy_correction_out_std_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_Tensor_sub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sub(self, other, alpha);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_sub_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_Lazy_out_sub_out_tmp = wrapper_Lazy_Tensor_sub(self, other, alpha);
  at::_copy_from_and_resize(wrapper_Lazy_out_sub_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy_Tensor_sub_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  auto wrapper_Lazy_Tensor_sub__tmp = wrapper_Lazy_Tensor_sub(self, other, alpha);
  at::_copy_from(wrapper_Lazy_Tensor_sub__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__sum(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sum(self, dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_sum_out(const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_Lazy_out_sum_out_tmp = wrapper_Lazy__sum(self, dtype);
  at::_copy_from_and_resize(wrapper_Lazy_out_sum_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_dim_IntList_sum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::sum(self, dim, keepdim, dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_IntList_out_sum_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_Lazy_IntList_out_sum_out_tmp = wrapper_Lazy_dim_IntList_sum(self, dim, keepdim, dtype);
  at::_copy_from_and_resize(wrapper_Lazy_IntList_out_sum_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__t_copy(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::t_copy(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_t_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_t_copy_out_tmp = wrapper_Lazy__t_copy(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_t_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__tanh(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::tanh(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_tanh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_tanh_out_tmp = wrapper_Lazy__tanh(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_tanh_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__tanh_(at::Tensor & self) {
  auto wrapper_Lazy__tanh__tmp = wrapper_Lazy__tanh(self);
  at::_copy_from(wrapper_Lazy__tanh__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__tanh_backward(const at::Tensor & grad_output, const at::Tensor & output) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::tanh_backward(grad_output, output);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_tanh_backward_out(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_tanh_backward_out_tmp = wrapper_Lazy__tanh_backward(grad_output, output);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_tanh_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__threshold(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::threshold(self, threshold, value);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_threshold_out(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_Lazy_out_threshold_out_tmp = wrapper_Lazy__threshold(self, threshold, value);
  at::_copy_from_and_resize(wrapper_Lazy_out_threshold_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__threshold_(at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
  auto wrapper_Lazy__threshold__tmp = wrapper_Lazy__threshold(self, threshold, value);
  at::_copy_from(wrapper_Lazy__threshold__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__threshold_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::threshold_backward(grad_output, self, threshold);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_threshold_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_threshold_backward_out_tmp = wrapper_Lazy__threshold_backward(grad_output, self, threshold);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_threshold_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_Lazy__topk(const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::topk(self, k.expect_int(), dim, largest, sorted);
}
} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Lazy_values_topk_out(const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
  auto wrapper_Lazy_values_topk_out_tmp = wrapper_Lazy__topk(self, k, dim, largest, sorted);
  at::_copy_from_and_resize(std::get<0>(wrapper_Lazy_values_topk_out_tmp), values);
  at::_copy_from_and_resize(std::get<1>(wrapper_Lazy_values_topk_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(values, indices);
}
namespace {
at::Tensor wrapper_Lazy__trace(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::trace(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_trace_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_trace_out_tmp = wrapper_Lazy__trace(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_trace_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_int_transpose_copy(const at::Tensor & self, int64_t dim0, int64_t dim1) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::transpose_copy(self, dim0, dim1);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_int_out_transpose_copy_out(const at::Tensor & self, int64_t dim0, int64_t dim1, at::Tensor & out) {
  auto wrapper_Lazy_int_out_transpose_copy_out_tmp = wrapper_Lazy_int_transpose_copy(self, dim0, dim1);
  at::_copy_from_and_resize(wrapper_Lazy_int_out_transpose_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__tril(const at::Tensor & self, int64_t diagonal) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::tril(self, diagonal);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_tril_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
  auto wrapper_Lazy_out_tril_out_tmp = wrapper_Lazy__tril(self, diagonal);
  at::_copy_from_and_resize(wrapper_Lazy_out_tril_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__tril_(at::Tensor & self, int64_t diagonal) {
  auto wrapper_Lazy__tril__tmp = wrapper_Lazy__tril(self, diagonal);
  at::_copy_from(wrapper_Lazy__tril__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__triu(const at::Tensor & self, int64_t diagonal) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::triu(self, diagonal);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_triu_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
  auto wrapper_Lazy_out_triu_out_tmp = wrapper_Lazy__triu(self, diagonal);
  at::_copy_from_and_resize(wrapper_Lazy_out_triu_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__triu_(at::Tensor & self, int64_t diagonal) {
  auto wrapper_Lazy__triu__tmp = wrapper_Lazy__triu(self, diagonal);
  at::_copy_from(wrapper_Lazy__triu__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__trunc(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::trunc(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_trunc_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_trunc_out_tmp = wrapper_Lazy__trunc(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_trunc_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__trunc_(at::Tensor & self) {
  auto wrapper_Lazy__trunc__tmp = wrapper_Lazy__trunc(self);
  at::_copy_from(wrapper_Lazy__trunc__tmp, self);
  return self;
}
namespace {
at::Tensor wrapper_Lazy__unfold_copy(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::unfold_copy(self, dimension, size, step);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_unfold_copy_out(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step, at::Tensor & out) {
  auto wrapper_Lazy_out_unfold_copy_out_tmp = wrapper_Lazy__unfold_copy(self, dimension, size, step);
  at::_copy_from_and_resize(wrapper_Lazy_out_unfold_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__unsqueeze_copy(const at::Tensor & self, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::unsqueeze_copy(self, dim);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_unsqueeze_copy_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
  auto wrapper_Lazy_out_unsqueeze_copy_out_tmp = wrapper_Lazy__unsqueeze_copy(self, dim);
  at::_copy_from_and_resize(wrapper_Lazy_out_unsqueeze_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__upsample_bilinear2d(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::upsample_bilinear2d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_upsample_bilinear2d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
  auto wrapper_Lazy_out_upsample_bilinear2d_out_tmp = wrapper_Lazy__upsample_bilinear2d(self, output_size, align_corners, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_Lazy_out_upsample_bilinear2d_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__upsample_bilinear2d_backward(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::upsample_bilinear2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_upsample_bilinear2d_backward_out(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_upsample_bilinear2d_backward_out_tmp = wrapper_Lazy__upsample_bilinear2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_upsample_bilinear2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__upsample_nearest2d(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::upsample_nearest2d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_upsample_nearest2d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
  auto wrapper_Lazy_out_upsample_nearest2d_out_tmp = wrapper_Lazy__upsample_nearest2d(self, output_size, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_Lazy_out_upsample_nearest2d_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__upsample_nearest2d_backward(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::upsample_nearest2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_grad_input_upsample_nearest2d_backward_out(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
  auto wrapper_Lazy_grad_input_upsample_nearest2d_backward_out_tmp = wrapper_Lazy__upsample_nearest2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_Lazy_grad_input_upsample_nearest2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {
at::Tensor wrapper_Lazy__view_copy(const at::Tensor & self, c10::SymIntArrayRef size) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::view_copy_symint(self, size);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_view_copy_out(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto wrapper_Lazy_out_view_copy_out_tmp = wrapper_Lazy__view_copy(self, size);
  at::_copy_from_and_resize(wrapper_Lazy_out_view_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy_dtype_view_copy(const at::Tensor & self, at::ScalarType dtype) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::view_copy(self, dtype);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_dtype_out_view_copy_out(const at::Tensor & self, at::ScalarType dtype, at::Tensor & out) {
  auto wrapper_Lazy_dtype_out_view_copy_out_tmp = wrapper_Lazy_dtype_view_copy(self, dtype);
  at::_copy_from_and_resize(wrapper_Lazy_dtype_out_view_copy_out_tmp, out);
  return out;
}
namespace {
at::Tensor wrapper_Lazy__zero(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return torch::lazy::LazyNativeFunctions::zero(self);
}
} // anonymous namespace
at::Tensor & wrapper_Lazy_out_zero_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_Lazy_out_zero_out_tmp = wrapper_Lazy__zero(self);
  at::_copy_from_and_resize(wrapper_Lazy_out_zero_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Lazy__zero_(at::Tensor & self) {
  auto wrapper_Lazy__zero__tmp = wrapper_Lazy__zero(self);
  at::_copy_from(wrapper_Lazy__zero__tmp, self);
  return self;
}
} // anonymous namespace
TORCH_API void RegisterTorchScriptLazyNativeFunctions();
TORCH_API void RegisterTorchScriptLazyNativeFunctions() {
    static auto m = MAKE_TORCH_LIBRARY_IMPL(aten, Lazy);
    m.impl("_adaptive_avg_pool2d",
    TORCH_FN(wrapper_Lazy___adaptive_avg_pool2d));
    m.impl("_adaptive_avg_pool2d.out",
    TORCH_FN(wrapper_Lazy_out__adaptive_avg_pool2d_out));
    m.impl("_adaptive_avg_pool2d_backward",
    TORCH_FN(wrapper_Lazy___adaptive_avg_pool2d_backward));
    m.impl("_adaptive_avg_pool2d_backward.out",
    TORCH_FN(wrapper_Lazy_out__adaptive_avg_pool2d_backward_out));
    m.impl("_copy_from",
    TORCH_FN(wrapper_Lazy___copy_from));
    m.impl("_copy_from.out",
    TORCH_FN(wrapper_Lazy_out__copy_from_out));
    m.impl("_copy_from_and_resize",
    TORCH_FN(wrapper_Lazy___copy_from_and_resize));
    m.impl("_copy_from_and_resize.out",
    TORCH_FN(wrapper_Lazy_out__copy_from_and_resize_out));
    m.impl("_log_softmax",
    TORCH_FN(wrapper_Lazy___log_softmax));
    m.impl("_log_softmax.out",
    TORCH_FN(wrapper_Lazy_out__log_softmax_out));
    m.impl("_log_softmax_backward_data",
    TORCH_FN(wrapper_Lazy___log_softmax_backward_data));
    m.impl("_log_softmax_backward_data.out",
    TORCH_FN(wrapper_Lazy_out__log_softmax_backward_data_out));
    m.impl("_reshape_alias_copy",
    TORCH_FN(wrapper_Lazy___reshape_alias_copy));
    m.impl("_reshape_alias_copy.out",
    TORCH_FN(wrapper_Lazy_out__reshape_alias_copy_out));
    m.impl("_softmax",
    TORCH_FN(wrapper_Lazy___softmax));
    m.impl("_softmax.out",
    TORCH_FN(wrapper_Lazy_out__softmax_out));
    m.impl("_softmax_backward_data",
    TORCH_FN(wrapper_Lazy___softmax_backward_data));
    m.impl("_softmax_backward_data.out",
    TORCH_FN(wrapper_Lazy_out__softmax_backward_data_out));
    m.impl("_to_copy",
    TORCH_FN(wrapper_Lazy___to_copy));
    m.impl("_to_copy.out",
    TORCH_FN(wrapper_Lazy_out__to_copy_out));
    m.impl("_trilinear",
    TORCH_FN(wrapper_Lazy___trilinear));
    m.impl("_trilinear.out",
    TORCH_FN(wrapper_Lazy_out__trilinear_out));
    m.impl("_unsafe_view",
    TORCH_FN(wrapper_Lazy___unsafe_view));
    m.impl("_unsafe_view.out",
    TORCH_FN(wrapper_Lazy_out__unsafe_view_out));
    m.impl("abs",
    TORCH_FN(wrapper_Lazy__abs));
    m.impl("abs.out",
    TORCH_FN(wrapper_Lazy_out_abs_out));
    m.impl("abs_",
    TORCH_FN(wrapper_Lazy__abs_));
    m.impl("add.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_add));
    m.impl("add.out",
    TORCH_FN(wrapper_Lazy_out_add_out));
    m.impl("add_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_add_));
    m.impl("addcdiv",
    TORCH_FN(wrapper_Lazy__addcdiv));
    m.impl("addcdiv.out",
    TORCH_FN(wrapper_Lazy_out_addcdiv_out));
    m.impl("addcdiv_",
    TORCH_FN(wrapper_Lazy__addcdiv_));
    m.impl("addcmul",
    TORCH_FN(wrapper_Lazy__addcmul));
    m.impl("addcmul.out",
    TORCH_FN(wrapper_Lazy_out_addcmul_out));
    m.impl("addcmul_",
    TORCH_FN(wrapper_Lazy__addcmul_));
    m.impl("addmm",
    TORCH_FN(wrapper_Lazy__addmm));
    m.impl("addmm.out",
    TORCH_FN(wrapper_Lazy_out_addmm_out));
    m.impl("addmm_",
    TORCH_FN(wrapper_Lazy__addmm_));
    m.impl("alias_copy",
    TORCH_FN(wrapper_Lazy__alias_copy));
    m.impl("alias_copy.out",
    TORCH_FN(wrapper_Lazy_out_alias_copy_out));
    m.impl("all",
    TORCH_FN(wrapper_Lazy__all));
    m.impl("all.all_out",
    TORCH_FN(wrapper_Lazy_all_out_all_out));
    m.impl("any",
    TORCH_FN(wrapper_Lazy__any));
    m.impl("any.all_out",
    TORCH_FN(wrapper_Lazy_all_out_any_out));
    m.impl("arange.start_out",
    TORCH_FN(wrapper_Lazy_start_out_arange_out));
    m.impl("as_strided_copy",
    TORCH_FN(wrapper_Lazy__as_strided_copy));
    m.impl("as_strided_copy.out",
    TORCH_FN(wrapper_Lazy_out_as_strided_copy_out));
    m.impl("as_strided_scatter",
    TORCH_FN(wrapper_Lazy__as_strided_scatter));
    m.impl("as_strided_scatter.out",
    TORCH_FN(wrapper_Lazy_out_as_strided_scatter_out));
    m.impl("avg_pool2d",
    TORCH_FN(wrapper_Lazy__avg_pool2d));
    m.impl("avg_pool2d.out",
    TORCH_FN(wrapper_Lazy_out_avg_pool2d_out));
    m.impl("avg_pool2d_backward",
    TORCH_FN(wrapper_Lazy__avg_pool2d_backward));
    m.impl("avg_pool2d_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_avg_pool2d_backward_out));
    m.impl("baddbmm",
    TORCH_FN(wrapper_Lazy__baddbmm));
    m.impl("baddbmm.out",
    TORCH_FN(wrapper_Lazy_out_baddbmm_out));
    m.impl("baddbmm_",
    TORCH_FN(wrapper_Lazy__baddbmm_));
    m.impl("bernoulli",
    TORCH_FN(wrapper_Lazy__bernoulli));
    m.impl("bernoulli.out",
    TORCH_FN(wrapper_Lazy_out_bernoulli_out));
    m.impl("bernoulli.p",
    TORCH_FN(wrapper_Lazy_p_bernoulli));
    m.impl("bernoulli.float_out",
    TORCH_FN(wrapper_Lazy_float_out_bernoulli_out));
    m.impl("bernoulli_.float",
    TORCH_FN(wrapper_Lazy_float_bernoulli_));
    m.impl("binary_cross_entropy",
    TORCH_FN(wrapper_Lazy__binary_cross_entropy));
    m.impl("binary_cross_entropy.out",
    TORCH_FN(wrapper_Lazy_out_binary_cross_entropy_out));
    m.impl("binary_cross_entropy_backward",
    TORCH_FN(wrapper_Lazy__binary_cross_entropy_backward));
    m.impl("binary_cross_entropy_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_binary_cross_entropy_backward_out));
    m.impl("bitwise_and.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_bitwise_and));
    m.impl("bitwise_and.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_bitwise_and_out));
    m.impl("bitwise_and_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_bitwise_and_));
    m.impl("bitwise_or.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_bitwise_or));
    m.impl("bitwise_or.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_bitwise_or_out));
    m.impl("bitwise_or_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_bitwise_or_));
    m.impl("block_diag",
    TORCH_FN(wrapper_Lazy__block_diag));
    m.impl("block_diag.out",
    TORCH_FN(wrapper_Lazy_out_block_diag_out));
    m.impl("bmm",
    TORCH_FN(wrapper_Lazy__bmm));
    m.impl("bmm.out",
    TORCH_FN(wrapper_Lazy_out_bmm_out));
    m.impl("cat",
    TORCH_FN(wrapper_Lazy__cat));
    m.impl("cat.out",
    TORCH_FN(wrapper_Lazy_out_cat_out));
    m.impl("clamp",
    TORCH_FN(wrapper_Lazy__clamp));
    m.impl("clamp.out",
    TORCH_FN(wrapper_Lazy_out_clamp_out));
    m.impl("clamp_",
    TORCH_FN(wrapper_Lazy__clamp_));
    m.impl("clamp_min",
    TORCH_FN(wrapper_Lazy__clamp_min));
    m.impl("clamp_min.out",
    TORCH_FN(wrapper_Lazy_out_clamp_min_out));
    m.impl("clamp_min_",
    TORCH_FN(wrapper_Lazy__clamp_min_));
    m.impl("clone",
    TORCH_FN(wrapper_Lazy__clone));
    m.impl("clone.out",
    TORCH_FN(wrapper_Lazy_out_clone_out));
    m.impl("constant_pad_nd",
    TORCH_FN(wrapper_Lazy__constant_pad_nd));
    m.impl("constant_pad_nd.out",
    TORCH_FN(wrapper_Lazy_out_constant_pad_nd_out));
    m.impl("convolution",
    TORCH_FN(wrapper_Lazy__convolution));
    m.impl("convolution.out",
    TORCH_FN(wrapper_Lazy_out_convolution_out));
    m.impl("convolution_backward",
    TORCH_FN(wrapper_Lazy__convolution_backward));
    m.impl("convolution_backward.out",
    TORCH_FN(wrapper_Lazy_out_convolution_backward_out));
    m.impl("cos",
    TORCH_FN(wrapper_Lazy__cos));
    m.impl("cos.out",
    TORCH_FN(wrapper_Lazy_out_cos_out));
    m.impl("cos_",
    TORCH_FN(wrapper_Lazy__cos_));
    m.impl("cumsum",
    TORCH_FN(wrapper_Lazy__cumsum));
    m.impl("cumsum.out",
    TORCH_FN(wrapper_Lazy_out_cumsum_out));
    m.impl("cumsum_",
    TORCH_FN(wrapper_Lazy__cumsum_));
    m.impl("detach_copy",
    TORCH_FN(wrapper_Lazy__detach_copy));
    m.impl("detach_copy.out",
    TORCH_FN(wrapper_Lazy_out_detach_copy_out));
    m.impl("diag_embed",
    TORCH_FN(wrapper_Lazy__diag_embed));
    m.impl("diag_embed.out",
    TORCH_FN(wrapper_Lazy_out_diag_embed_out));
    m.impl("diagonal_backward",
    TORCH_FN(wrapper_Lazy__diagonal_backward));
    m.impl("diagonal_backward.out",
    TORCH_FN(wrapper_Lazy_out_diagonal_backward_out));
    m.impl("diagonal_copy",
    TORCH_FN(wrapper_Lazy__diagonal_copy));
    m.impl("diagonal_copy.out",
    TORCH_FN(wrapper_Lazy_out_diagonal_copy_out));
    m.impl("diagonal_scatter",
    TORCH_FN(wrapper_Lazy__diagonal_scatter));
    m.impl("diagonal_scatter.out",
    TORCH_FN(wrapper_Lazy_out_diagonal_scatter_out));
    m.impl("div.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_div));
    m.impl("div.out",
    TORCH_FN(wrapper_Lazy_out_div_out));
    m.impl("div_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_div_));
    m.impl("div.Tensor_mode",
    TORCH_FN(wrapper_Lazy_Tensor_mode_div));
    m.impl("div.out_mode",
    TORCH_FN(wrapper_Lazy_out_mode_div_out));
    m.impl("div_.Tensor_mode",
    TORCH_FN(wrapper_Lazy_Tensor_mode_div_));
    m.impl("elu",
    TORCH_FN(wrapper_Lazy__elu));
    m.impl("elu.out",
    TORCH_FN(wrapper_Lazy_out_elu_out));
    m.impl("elu_",
    TORCH_FN(wrapper_Lazy__elu_));
    m.impl("elu_backward",
    TORCH_FN(wrapper_Lazy__elu_backward));
    m.impl("elu_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_elu_backward_out));
    m.impl("embedding",
    TORCH_FN(wrapper_Lazy__embedding));
    m.impl("embedding.out",
    TORCH_FN(wrapper_Lazy_out_embedding_out));
    m.impl("embedding_dense_backward",
    TORCH_FN(wrapper_Lazy__embedding_dense_backward));
    m.impl("embedding_dense_backward.out",
    TORCH_FN(wrapper_Lazy_out_embedding_dense_backward_out));
    m.impl("empty.memory_format",
    TORCH_FN(wrapper_Lazy_memory_format_empty));
    m.impl("empty.out",
    TORCH_FN(wrapper_Lazy_out_empty_out));
    m.impl("empty_strided",
    TORCH_FN(wrapper_Lazy__empty_strided));
    m.impl("empty_strided.out",
    TORCH_FN(wrapper_Lazy_out_empty_strided_out));
    m.impl("eq.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_eq));
    m.impl("eq.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_eq_out));
    m.impl("eq_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_eq_));
    m.impl("eq.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_eq));
    m.impl("eq.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_eq_out));
    m.impl("eq_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_eq_));
    m.impl("exp",
    TORCH_FN(wrapper_Lazy__exp));
    m.impl("exp.out",
    TORCH_FN(wrapper_Lazy_out_exp_out));
    m.impl("exp_",
    TORCH_FN(wrapper_Lazy__exp_));
    m.impl("expand_copy",
    TORCH_FN(wrapper_Lazy__expand_copy));
    m.impl("expand_copy.out",
    TORCH_FN(wrapper_Lazy_out_expand_copy_out));
    m.impl("fill_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_fill_));
    m.impl("flip",
    TORCH_FN(wrapper_Lazy__flip));
    m.impl("flip.out",
    TORCH_FN(wrapper_Lazy_out_flip_out));
    m.impl("floor",
    TORCH_FN(wrapper_Lazy__floor));
    m.impl("floor.out",
    TORCH_FN(wrapper_Lazy_out_floor_out));
    m.impl("floor_",
    TORCH_FN(wrapper_Lazy__floor_));
    m.impl("frac",
    TORCH_FN(wrapper_Lazy__frac));
    m.impl("frac.out",
    TORCH_FN(wrapper_Lazy_out_frac_out));
    m.impl("frac_",
    TORCH_FN(wrapper_Lazy__frac_));
    m.impl("gather",
    TORCH_FN(wrapper_Lazy__gather));
    m.impl("gather.out",
    TORCH_FN(wrapper_Lazy_out_gather_out));
    m.impl("ge.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_ge));
    m.impl("ge.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_ge_out));
    m.impl("ge_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_ge_));
    m.impl("ge.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_ge));
    m.impl("ge.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_ge_out));
    m.impl("ge_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_ge_));
    m.impl("gelu",
    TORCH_FN(wrapper_Lazy__gelu));
    m.impl("gelu.out",
    TORCH_FN(wrapper_Lazy_out_gelu_out));
    m.impl("gelu_",
    TORCH_FN(wrapper_Lazy__gelu_));
    m.impl("gelu_backward",
    TORCH_FN(wrapper_Lazy__gelu_backward));
    m.impl("gelu_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_gelu_backward_out));
    m.impl("glu",
    TORCH_FN(wrapper_Lazy__glu));
    m.impl("glu.out",
    TORCH_FN(wrapper_Lazy_out_glu_out));
    m.impl("glu_backward",
    TORCH_FN(wrapper_Lazy__glu_backward));
    m.impl("glu_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_glu_backward_out));
    m.impl("glu_jvp",
    TORCH_FN(wrapper_Lazy__glu_jvp));
    m.impl("glu_jvp.out",
    TORCH_FN(wrapper_Lazy_out_glu_jvp_out));
    m.impl("grid_sampler_2d",
    TORCH_FN(wrapper_Lazy__grid_sampler_2d));
    m.impl("grid_sampler_2d.out",
    TORCH_FN(wrapper_Lazy_out_grid_sampler_2d_out));
    m.impl("grid_sampler_2d_backward",
    TORCH_FN(wrapper_Lazy__grid_sampler_2d_backward));
    m.impl("grid_sampler_2d_backward.out",
    TORCH_FN(wrapper_Lazy_out_grid_sampler_2d_backward_out));
    m.impl("gt.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_gt));
    m.impl("gt.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_gt_out));
    m.impl("gt_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_gt_));
    m.impl("gt.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_gt));
    m.impl("gt.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_gt_out));
    m.impl("gt_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_gt_));
    m.impl("hardsigmoid",
    TORCH_FN(wrapper_Lazy__hardsigmoid));
    m.impl("hardsigmoid.out",
    TORCH_FN(wrapper_Lazy_out_hardsigmoid_out));
    m.impl("hardsigmoid_",
    TORCH_FN(wrapper_Lazy__hardsigmoid_));
    m.impl("index_select",
    TORCH_FN(wrapper_Lazy__index_select));
    m.impl("index_select.out",
    TORCH_FN(wrapper_Lazy_out_index_select_out));
    m.impl("le.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_le));
    m.impl("le.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_le_out));
    m.impl("le_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_le_));
    m.impl("le.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_le));
    m.impl("le.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_le_out));
    m.impl("le_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_le_));
    m.impl("leaky_relu",
    TORCH_FN(wrapper_Lazy__leaky_relu));
    m.impl("leaky_relu.out",
    TORCH_FN(wrapper_Lazy_out_leaky_relu_out));
    m.impl("leaky_relu_",
    TORCH_FN(wrapper_Lazy__leaky_relu_));
    m.impl("leaky_relu_backward",
    TORCH_FN(wrapper_Lazy__leaky_relu_backward));
    m.impl("leaky_relu_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_leaky_relu_backward_out));
    m.impl("lift",
    TORCH_FN(wrapper_Lazy__lift));
    m.impl("lift.out",
    TORCH_FN(wrapper_Lazy_out_lift_out));
    m.impl("lift_fresh",
    TORCH_FN(wrapper_Lazy__lift_fresh));
    m.impl("linalg_pinv.atol_rtol_tensor",
    TORCH_FN(wrapper_Lazy_atol_rtol_tensor_linalg_pinv));
    m.impl("linalg_pinv.atol_rtol_tensor_out",
    TORCH_FN(wrapper_Lazy_atol_rtol_tensor_out_linalg_pinv_out));
    m.impl("log",
    TORCH_FN(wrapper_Lazy__log));
    m.impl("log.out",
    TORCH_FN(wrapper_Lazy_out_log_out));
    m.impl("log_",
    TORCH_FN(wrapper_Lazy__log_));
    m.impl("log2",
    TORCH_FN(wrapper_Lazy__log2));
    m.impl("log2.out",
    TORCH_FN(wrapper_Lazy_out_log2_out));
    m.impl("log2_",
    TORCH_FN(wrapper_Lazy__log2_));
    m.impl("log_sigmoid_backward",
    TORCH_FN(wrapper_Lazy__log_sigmoid_backward));
    m.impl("log_sigmoid_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_log_sigmoid_backward_out));
    m.impl("log_sigmoid_forward",
    TORCH_FN(wrapper_Lazy__log_sigmoid_forward));
    m.impl("log_sigmoid_forward.output",
    TORCH_FN(wrapper_Lazy_output_log_sigmoid_forward_out));
    m.impl("logdet",
    TORCH_FN(wrapper_Lazy__logdet));
    m.impl("logsumexp.out",
    TORCH_FN(wrapper_Lazy_out_logsumexp_out));
    m.impl("lt.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_lt));
    m.impl("lt.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_lt_out));
    m.impl("lt_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_lt_));
    m.impl("lt.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_lt));
    m.impl("lt.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_lt_out));
    m.impl("lt_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_lt_));
    m.impl("masked_fill.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_masked_fill));
    m.impl("masked_fill.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_masked_fill_out));
    m.impl("masked_fill_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_masked_fill_));
    m.impl("masked_fill.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_masked_fill));
    m.impl("masked_fill.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_masked_fill_out));
    m.impl("masked_fill_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_masked_fill_));
    m.impl("max.dim",
    TORCH_FN(wrapper_Lazy_dim_max));
    m.impl("max.dim_max",
    TORCH_FN(wrapper_Lazy_dim_max_max_out));
    m.impl("max",
    TORCH_FN(wrapper_Lazy__max));
    m.impl("max.unary_out",
    TORCH_FN(wrapper_Lazy_unary_out_max_out));
    m.impl("max_pool2d_with_indices",
    TORCH_FN(wrapper_Lazy__max_pool2d_with_indices));
    m.impl("max_pool2d_with_indices.out",
    TORCH_FN(wrapper_Lazy_out_max_pool2d_with_indices_out));
    m.impl("max_pool2d_with_indices_backward",
    TORCH_FN(wrapper_Lazy__max_pool2d_with_indices_backward));
    m.impl("max_pool2d_with_indices_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_max_pool2d_with_indices_backward_out));
    m.impl("max_pool3d_with_indices",
    TORCH_FN(wrapper_Lazy__max_pool3d_with_indices));
    m.impl("max_pool3d_with_indices.out",
    TORCH_FN(wrapper_Lazy_out_max_pool3d_with_indices_out));
    m.impl("max_pool3d_with_indices_backward",
    TORCH_FN(wrapper_Lazy__max_pool3d_with_indices_backward));
    m.impl("max_pool3d_with_indices_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_max_pool3d_with_indices_backward_out));
    m.impl("maximum",
    TORCH_FN(wrapper_Lazy__maximum));
    m.impl("maximum.out",
    TORCH_FN(wrapper_Lazy_out_maximum_out));
    m.impl("mean",
    TORCH_FN(wrapper_Lazy__mean));
    m.impl("mean.dim",
    TORCH_FN(wrapper_Lazy_dim_mean));
    m.impl("mean.out",
    TORCH_FN(wrapper_Lazy_out_mean_out));
    m.impl("min",
    TORCH_FN(wrapper_Lazy__min));
    m.impl("min.unary_out",
    TORCH_FN(wrapper_Lazy_unary_out_min_out));
    m.impl("minimum",
    TORCH_FN(wrapper_Lazy__minimum));
    m.impl("minimum.out",
    TORCH_FN(wrapper_Lazy_out_minimum_out));
    m.impl("mm",
    TORCH_FN(wrapper_Lazy__mm));
    m.impl("mm.out",
    TORCH_FN(wrapper_Lazy_out_mm_out));
    m.impl("mul.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_mul));
    m.impl("mul.out",
    TORCH_FN(wrapper_Lazy_out_mul_out));
    m.impl("mul_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_mul_));
    m.impl("mv",
    TORCH_FN(wrapper_Lazy__mv));
    m.impl("mv.out",
    TORCH_FN(wrapper_Lazy_out_mv_out));
    m.impl("narrow_copy",
    TORCH_FN(wrapper_Lazy__narrow_copy));
    m.impl("narrow_copy.out",
    TORCH_FN(wrapper_Lazy_out_narrow_copy_out));
    m.impl("native_batch_norm",
    TORCH_FN(wrapper_Lazy__native_batch_norm));
    m.impl("native_batch_norm.out",
    TORCH_FN(wrapper_Lazy_out_native_batch_norm_out));
    m.impl("native_batch_norm_backward",
    TORCH_FN(wrapper_Lazy__native_batch_norm_backward));
    m.impl("native_batch_norm_backward.out",
    TORCH_FN(wrapper_Lazy_out_native_batch_norm_backward_out));
    m.impl("native_dropout",
    TORCH_FN(wrapper_Lazy__native_dropout));
    m.impl("native_dropout.out",
    TORCH_FN(wrapper_Lazy_out_native_dropout_out));
    m.impl("native_dropout_backward",
    TORCH_FN(wrapper_Lazy__native_dropout_backward));
    m.impl("native_dropout_backward.out",
    TORCH_FN(wrapper_Lazy_out_native_dropout_backward_out));
    m.impl("native_layer_norm",
    TORCH_FN(wrapper_Lazy__native_layer_norm));
    m.impl("native_layer_norm.out",
    TORCH_FN(wrapper_Lazy_out_native_layer_norm_out));
    m.impl("native_layer_norm_backward",
    TORCH_FN(wrapper_Lazy__native_layer_norm_backward));
    m.impl("native_layer_norm_backward.out",
    TORCH_FN(wrapper_Lazy_out_native_layer_norm_backward_out));
    m.impl("ne.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_ne));
    m.impl("ne.Scalar_out",
    TORCH_FN(wrapper_Lazy_Scalar_out_ne_out));
    m.impl("ne_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_ne_));
    m.impl("ne.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_ne));
    m.impl("ne.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_ne_out));
    m.impl("ne_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_ne_));
    m.impl("neg",
    TORCH_FN(wrapper_Lazy__neg));
    m.impl("neg.out",
    TORCH_FN(wrapper_Lazy_out_neg_out));
    m.impl("neg_",
    TORCH_FN(wrapper_Lazy__neg_));
    m.impl("new_empty_strided",
    TORCH_FN(wrapper_Lazy__new_empty_strided));
    m.impl("new_empty_strided.out",
    TORCH_FN(wrapper_Lazy_out_new_empty_strided_out));
    m.impl("nll_loss2d_backward",
    TORCH_FN(wrapper_Lazy__nll_loss2d_backward));
    m.impl("nll_loss2d_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_nll_loss2d_backward_out));
    m.impl("nll_loss2d_forward",
    TORCH_FN(wrapper_Lazy__nll_loss2d_forward));
    m.impl("nll_loss2d_forward.output",
    TORCH_FN(wrapper_Lazy_output_nll_loss2d_forward_out));
    m.impl("nll_loss_backward",
    TORCH_FN(wrapper_Lazy__nll_loss_backward));
    m.impl("nll_loss_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_nll_loss_backward_out));
    m.impl("nll_loss_forward",
    TORCH_FN(wrapper_Lazy__nll_loss_forward));
    m.impl("nll_loss_forward.output",
    TORCH_FN(wrapper_Lazy_output_nll_loss_forward_out));
    m.impl("nonzero",
    TORCH_FN(wrapper_Lazy__nonzero));
    m.impl("nonzero.out",
    TORCH_FN(wrapper_Lazy_out_nonzero_out));
    m.impl("norm.ScalarOpt_dim",
    TORCH_FN(wrapper_Lazy_ScalarOpt_dim_norm));
    m.impl("norm.out",
    TORCH_FN(wrapper_Lazy_out_norm_out));
    m.impl("normal_",
    TORCH_FN(wrapper_Lazy__normal_));
    m.impl("permute_copy",
    TORCH_FN(wrapper_Lazy__permute_copy));
    m.impl("permute_copy.out",
    TORCH_FN(wrapper_Lazy_out_permute_copy_out));
    m.impl("pixel_shuffle",
    TORCH_FN(wrapper_Lazy__pixel_shuffle));
    m.impl("pixel_shuffle.out",
    TORCH_FN(wrapper_Lazy_out_pixel_shuffle_out));
    m.impl("pixel_unshuffle",
    TORCH_FN(wrapper_Lazy__pixel_unshuffle));
    m.impl("pixel_unshuffle.out",
    TORCH_FN(wrapper_Lazy_out_pixel_unshuffle_out));
    m.impl("pow.Tensor_Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_Tensor_pow));
    m.impl("pow.Tensor_Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_Tensor_out_pow_out));
    m.impl("pow_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_pow_));
    m.impl("pow.Tensor_Scalar",
    TORCH_FN(wrapper_Lazy_Tensor_Scalar_pow));
    m.impl("pow.Tensor_Scalar_out",
    TORCH_FN(wrapper_Lazy_Tensor_Scalar_out_pow_out));
    m.impl("pow_.Scalar",
    TORCH_FN(wrapper_Lazy_Scalar_pow_));
    m.impl("random.from",
    TORCH_FN(wrapper_Lazy_from_random));
    m.impl("random.from_out",
    TORCH_FN(wrapper_Lazy_from_out_random_out));
    m.impl("random_.from",
    TORCH_FN(wrapper_Lazy_from_random_));
    m.impl("random.to",
    TORCH_FN(wrapper_Lazy_to_random));
    m.impl("random.to_out",
    TORCH_FN(wrapper_Lazy_to_out_random_out));
    m.impl("random_.to",
    TORCH_FN(wrapper_Lazy_to_random_));
    m.impl("random",
    TORCH_FN(wrapper_Lazy__random));
    m.impl("random.out",
    TORCH_FN(wrapper_Lazy_out_random_out));
    m.impl("random_",
    TORCH_FN(wrapper_Lazy__random_));
    m.impl("reciprocal",
    TORCH_FN(wrapper_Lazy__reciprocal));
    m.impl("reciprocal.out",
    TORCH_FN(wrapper_Lazy_out_reciprocal_out));
    m.impl("reciprocal_",
    TORCH_FN(wrapper_Lazy__reciprocal_));
    m.impl("relu",
    TORCH_FN(wrapper_Lazy__relu));
    m.impl("relu.out",
    TORCH_FN(wrapper_Lazy_out_relu_out));
    m.impl("relu_",
    TORCH_FN(wrapper_Lazy__relu_));
    m.impl("remainder.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_remainder));
    m.impl("remainder.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_remainder_out));
    m.impl("remainder_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_remainder_));
    m.impl("repeat",
    TORCH_FN(wrapper_Lazy__repeat));
    m.impl("repeat.out",
    TORCH_FN(wrapper_Lazy_out_repeat_out));
    m.impl("rsqrt",
    TORCH_FN(wrapper_Lazy__rsqrt));
    m.impl("rsqrt.out",
    TORCH_FN(wrapper_Lazy_out_rsqrt_out));
    m.impl("rsqrt_",
    TORCH_FN(wrapper_Lazy__rsqrt_));
    m.impl("scatter_add",
    TORCH_FN(wrapper_Lazy__scatter_add));
    m.impl("scatter_add.out",
    TORCH_FN(wrapper_Lazy_out_scatter_add_out));
    m.impl("scatter_add_",
    TORCH_FN(wrapper_Lazy__scatter_add_));
    m.impl("select_backward",
    TORCH_FN(wrapper_Lazy__select_backward));
    m.impl("select_backward.out",
    TORCH_FN(wrapper_Lazy_out_select_backward_out));
    m.impl("select_copy.int",
    TORCH_FN(wrapper_Lazy_int_select_copy));
    m.impl("select_copy.int_out",
    TORCH_FN(wrapper_Lazy_int_out_select_copy_out));
    m.impl("select_scatter",
    TORCH_FN(wrapper_Lazy__select_scatter));
    m.impl("select_scatter.out",
    TORCH_FN(wrapper_Lazy_out_select_scatter_out));
    m.impl("sgn",
    TORCH_FN(wrapper_Lazy__sgn));
    m.impl("sgn.out",
    TORCH_FN(wrapper_Lazy_out_sgn_out));
    m.impl("sgn_",
    TORCH_FN(wrapper_Lazy__sgn_));
    m.impl("sigmoid",
    TORCH_FN(wrapper_Lazy__sigmoid));
    m.impl("sigmoid.out",
    TORCH_FN(wrapper_Lazy_out_sigmoid_out));
    m.impl("sigmoid_",
    TORCH_FN(wrapper_Lazy__sigmoid_));
    m.impl("sigmoid_backward",
    TORCH_FN(wrapper_Lazy__sigmoid_backward));
    m.impl("sigmoid_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_sigmoid_backward_out));
    m.impl("silu",
    TORCH_FN(wrapper_Lazy__silu));
    m.impl("silu.out",
    TORCH_FN(wrapper_Lazy_out_silu_out));
    m.impl("silu_",
    TORCH_FN(wrapper_Lazy__silu_));
    m.impl("slice_backward",
    TORCH_FN(wrapper_Lazy__slice_backward));
    m.impl("slice_backward.out",
    TORCH_FN(wrapper_Lazy_out_slice_backward_out));
    m.impl("slice_copy.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_slice_copy));
    m.impl("slice_copy.Tensor_out",
    TORCH_FN(wrapper_Lazy_Tensor_out_slice_copy_out));
    m.impl("slice_scatter",
    TORCH_FN(wrapper_Lazy__slice_scatter));
    m.impl("slice_scatter.out",
    TORCH_FN(wrapper_Lazy_out_slice_scatter_out));
    m.impl("smooth_l1_loss",
    TORCH_FN(wrapper_Lazy__smooth_l1_loss));
    m.impl("smooth_l1_loss.out",
    TORCH_FN(wrapper_Lazy_out_smooth_l1_loss_out));
    m.impl("smooth_l1_loss_backward",
    TORCH_FN(wrapper_Lazy__smooth_l1_loss_backward));
    m.impl("smooth_l1_loss_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_smooth_l1_loss_backward_out));
    m.impl("softplus",
    TORCH_FN(wrapper_Lazy__softplus));
    m.impl("softplus.out",
    TORCH_FN(wrapper_Lazy_out_softplus_out));
    m.impl("softplus_backward",
    TORCH_FN(wrapper_Lazy__softplus_backward));
    m.impl("softplus_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_softplus_backward_out));
    m.impl("sort",
    TORCH_FN(wrapper_Lazy__sort));
    m.impl("sort.values",
    TORCH_FN(wrapper_Lazy_values_sort_out));
    m.impl("sqrt",
    TORCH_FN(wrapper_Lazy__sqrt));
    m.impl("sqrt.out",
    TORCH_FN(wrapper_Lazy_out_sqrt_out));
    m.impl("sqrt_",
    TORCH_FN(wrapper_Lazy__sqrt_));
    m.impl("squeeze_copy",
    TORCH_FN(wrapper_Lazy__squeeze_copy));
    m.impl("squeeze_copy.out",
    TORCH_FN(wrapper_Lazy_out_squeeze_copy_out));
    m.impl("squeeze_copy.dim",
    TORCH_FN(wrapper_Lazy_dim_squeeze_copy));
    m.impl("squeeze_copy.dim_out",
    TORCH_FN(wrapper_Lazy_dim_out_squeeze_copy_out));
    m.impl("squeeze_copy.dims",
    TORCH_FN(wrapper_Lazy_dims_squeeze_copy));
    m.impl("squeeze_copy.dims_out",
    TORCH_FN(wrapper_Lazy_dims_out_squeeze_copy_out));
    m.impl("stack",
    TORCH_FN(wrapper_Lazy__stack));
    m.impl("stack.out",
    TORCH_FN(wrapper_Lazy_out_stack_out));
    m.impl("std",
    TORCH_FN(wrapper_Lazy__std));
    m.impl("std.dim",
    TORCH_FN(wrapper_Lazy_dim_std));
    m.impl("std.out",
    TORCH_FN(wrapper_Lazy_out_std_out));
    m.impl("std.correction",
    TORCH_FN(wrapper_Lazy_correction_std));
    m.impl("std.correction_out",
    TORCH_FN(wrapper_Lazy_correction_out_std_out));
    m.impl("sub.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_sub));
    m.impl("sub.out",
    TORCH_FN(wrapper_Lazy_out_sub_out));
    m.impl("sub_.Tensor",
    TORCH_FN(wrapper_Lazy_Tensor_sub_));
    m.impl("sum",
    TORCH_FN(wrapper_Lazy__sum));
    m.impl("sum.out",
    TORCH_FN(wrapper_Lazy_out_sum_out));
    m.impl("sum.dim_IntList",
    TORCH_FN(wrapper_Lazy_dim_IntList_sum));
    m.impl("sum.IntList_out",
    TORCH_FN(wrapper_Lazy_IntList_out_sum_out));
    m.impl("t_copy",
    TORCH_FN(wrapper_Lazy__t_copy));
    m.impl("t_copy.out",
    TORCH_FN(wrapper_Lazy_out_t_copy_out));
    m.impl("tanh",
    TORCH_FN(wrapper_Lazy__tanh));
    m.impl("tanh.out",
    TORCH_FN(wrapper_Lazy_out_tanh_out));
    m.impl("tanh_",
    TORCH_FN(wrapper_Lazy__tanh_));
    m.impl("tanh_backward",
    TORCH_FN(wrapper_Lazy__tanh_backward));
    m.impl("tanh_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_tanh_backward_out));
    m.impl("threshold",
    TORCH_FN(wrapper_Lazy__threshold));
    m.impl("threshold.out",
    TORCH_FN(wrapper_Lazy_out_threshold_out));
    m.impl("threshold_",
    TORCH_FN(wrapper_Lazy__threshold_));
    m.impl("threshold_backward",
    TORCH_FN(wrapper_Lazy__threshold_backward));
    m.impl("threshold_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_threshold_backward_out));
    m.impl("topk",
    TORCH_FN(wrapper_Lazy__topk));
    m.impl("topk.values",
    TORCH_FN(wrapper_Lazy_values_topk_out));
    m.impl("trace",
    TORCH_FN(wrapper_Lazy__trace));
    m.impl("trace.out",
    TORCH_FN(wrapper_Lazy_out_trace_out));
    m.impl("transpose_copy.int",
    TORCH_FN(wrapper_Lazy_int_transpose_copy));
    m.impl("transpose_copy.int_out",
    TORCH_FN(wrapper_Lazy_int_out_transpose_copy_out));
    m.impl("tril",
    TORCH_FN(wrapper_Lazy__tril));
    m.impl("tril.out",
    TORCH_FN(wrapper_Lazy_out_tril_out));
    m.impl("tril_",
    TORCH_FN(wrapper_Lazy__tril_));
    m.impl("triu",
    TORCH_FN(wrapper_Lazy__triu));
    m.impl("triu.out",
    TORCH_FN(wrapper_Lazy_out_triu_out));
    m.impl("triu_",
    TORCH_FN(wrapper_Lazy__triu_));
    m.impl("trunc",
    TORCH_FN(wrapper_Lazy__trunc));
    m.impl("trunc.out",
    TORCH_FN(wrapper_Lazy_out_trunc_out));
    m.impl("trunc_",
    TORCH_FN(wrapper_Lazy__trunc_));
    m.impl("unfold_copy",
    TORCH_FN(wrapper_Lazy__unfold_copy));
    m.impl("unfold_copy.out",
    TORCH_FN(wrapper_Lazy_out_unfold_copy_out));
    m.impl("unsqueeze_copy",
    TORCH_FN(wrapper_Lazy__unsqueeze_copy));
    m.impl("unsqueeze_copy.out",
    TORCH_FN(wrapper_Lazy_out_unsqueeze_copy_out));
    m.impl("upsample_bilinear2d",
    TORCH_FN(wrapper_Lazy__upsample_bilinear2d));
    m.impl("upsample_bilinear2d.out",
    TORCH_FN(wrapper_Lazy_out_upsample_bilinear2d_out));
    m.impl("upsample_bilinear2d_backward",
    TORCH_FN(wrapper_Lazy__upsample_bilinear2d_backward));
    m.impl("upsample_bilinear2d_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_upsample_bilinear2d_backward_out));
    m.impl("upsample_nearest2d",
    TORCH_FN(wrapper_Lazy__upsample_nearest2d));
    m.impl("upsample_nearest2d.out",
    TORCH_FN(wrapper_Lazy_out_upsample_nearest2d_out));
    m.impl("upsample_nearest2d_backward",
    TORCH_FN(wrapper_Lazy__upsample_nearest2d_backward));
    m.impl("upsample_nearest2d_backward.grad_input",
    TORCH_FN(wrapper_Lazy_grad_input_upsample_nearest2d_backward_out));
    m.impl("view_copy",
    TORCH_FN(wrapper_Lazy__view_copy));
    m.impl("view_copy.out",
    TORCH_FN(wrapper_Lazy_out_view_copy_out));
    m.impl("view_copy.dtype",
    TORCH_FN(wrapper_Lazy_dtype_view_copy));
    m.impl("view_copy.dtype_out",
    TORCH_FN(wrapper_Lazy_dtype_out_view_copy_out));
    m.impl("zero",
    TORCH_FN(wrapper_Lazy__zero));
    m.impl("zero.out",
    TORCH_FN(wrapper_Lazy_out_zero_out));
    m.impl("zero_",
    TORCH_FN(wrapper_Lazy__zero_));
}
namespace lazy {
} // namespace lazy
} // namespace at
